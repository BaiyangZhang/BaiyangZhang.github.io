<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://baiyangzhang.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://baiyangzhang.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-21T09:29:50+00:00</updated><id>https://baiyangzhang.github.io/feed.xml</id><title type="html">Baiyang Zhang</title><subtitle>A place dedicated to sharing insights and reflections on mathematics, physics, and social sciences. </subtitle><entry><title type="html">Categorical Equivalence and the Renormalization Group</title><link href="https://baiyangzhang.github.io/blog/2023/Categorical-Equivalence-and-the-Renormalization-Group/" rel="alternate" type="text/html" title="Categorical Equivalence and the Renormalization Group"/><published>2023-11-18T00:00:00+00:00</published><updated>2023-11-18T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Categorical-Equivalence-and-the-Renormalization-Group</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Categorical-Equivalence-and-the-Renormalization-Group/"><![CDATA[<p><em>Disclaimer: Nothing in this note is original.</em></p> <p>A short introduction about sheaf can be found <a href="https://www.mathlimbo.net/blog/2023/Basic-Algebraic-Geometry-6/">here</a>.</p> <h4 id="gauged-linear-sigma-model">Gauged linear sigma model</h4> <p>A gauged linear sigma model (GLSM) is a type of quantum field theory that incorporates both gauge symmetry and a set of scalar fields which interact with each other through a potential that is usually taken to be a function of the sum of the squares of the scalar fields. These models are a generalization of the linear sigma models that were originally introduced to describe the dynamics of pions in particle physics.</p> <p>The term “linear” in this context refers to the fact that the potential energy function for the scalar fields is quadratic, at least around the vacuum of the theory. This means that the interactions can be written in terms of fields and their derivatives in a polynomial form that does not exceed second degree when expanded about the vacuum expectation value.</p> <p>Often, GLSMs are discussed in the context of supersymmetry. This means that for every boson (like the scalar fields and gauge fields in the model), there is a corresponding fermion. Supersymmetric GLSMs are particularly interesting for string theory and the study of Calabi-Yau manifolds.</p> <p>In essence, the gauged linear sigma model allows for the study of a wide array of phenomena including spontaneous symmetry breaking, phase transitions, and the dynamics of topological defects. By gauging a symmetry, you add a rich structure to the model that includes interactions mediated by gauge bosons and the possibility of incorporating richer topological properties.</p> <p>A key feature of GLSMs is that they can have a “Higgs phase,” where the gauge symmetry is spontaneously broken and the gauge bosons acquire mass via the Higgs mechanism, and a “Coulomb phase,” where the gauge symmetry is unbroken and the gauge bosons remain massless. Transitions between these phases can often be studied using GLSMs, providing insights into non-perturbative aspects of quantum field theories.</p> <h4 id="toric-variety">Toric variety</h4> <p>We all know what a variety is. So what is a toric variety?</p> <p>A toric variety is a type of variety that is built from combinatorial objects known as fans, which are collections of cones. Toric varieties are particularly nice because they provide a bridge between algebraic geometry and combinatorics, and they are also rich in geometric properties.</p> <p><strong>Algebraic Torus.</strong></p> <p>Start with an algebraic torus $( \mathbb{C}^* )^n$, which is the product of $n$ copies of the multiplicative group $\mathbb{C}^* = \mathbb{C} \setminus {0}$. This group acts on itself by multiplication, and this action can be extended to act on other algebraic varieties.</p> <p><strong>Fans and Cones.</strong></p> <p>A fan is a set of cones (not in the usual sense of solid geometry, but in the sense of vector spaces). These cones are generated by a set of vectors in $\mathbb{R}^n$ that satisfy certain combinatorial conditions – they must be strongly convex (no line can be contained in a cone), and the intersection of any two cones in the fan must be a face of each. The dimension of the toric variety is equal to the dimension of the space where the fan lives.</p> <p><strong>Construction of Toric Varieties.</strong></p> <p>Each cone in the fan corresponds to an affine variety that is invariant under the action of a subtorus of $( \mathbb{C}^* )^n$. The toric variety is constructed by “gluing” these affine varieties together in a way that corresponds to how their cones intersect.</p> <p><strong>Divisors and Line Bundles.</strong> Toric varieties are also interesting because there is a correspondence between the combinatorial data of the fan and the divisor class group of the variety. This makes the calculation of certain cohomological and geometric properties much simpler than in general varieties.</p> <p>A key feature of toric varieties is that they come with a lot of symmetry – namely, the action of the torus. This symmetry makes them easier to study and gives them a rich structure. Toric varieties have applications in many areas of mathematics, including combinatorics, symplectic geometry, and mirror symmetry in string theory. They serve as local models in the Minimal Model Program and are also used in the study of singularities.</p> <p>For a concrete example, consider the complex projective space $\mathbb{CP}^n$, which is a toric variety. The fan for $\mathbb{CP}^n$ consists of cones that correspond to the origin and the standard basis vectors in $\mathbb{R}^n$, as well as all their faces. The rich interplay between the algebraic and combinatorial structures of toric varieties makes them a fascinating subject of study in modern algebraic geometry.</p> <h4 id="stacks">Stacks</h4> <p>Let $\mathcal{T}$ be the category of topological spaces, where the objects are topological spaces and the morphisms are continuous maps.</p> <p>A <strong>groupoid fibration,</strong> or a category fibered <em>in</em> groupoids, over $\mathcal{T}$ is another category (which is a groupoid) $\mathcal{X}$, together with a functor \(F: \mathcal{X} \to \mathcal{T}\) such that there exists a pullback and the pull back is unique. First, some terminologies. If the functor maps $X \in \mathcal{X}$ to $T \in \mathcal{T}$ then we say that $X$ lies over $T$, or that $X$ is a $\mathcal{X}$-family parametrized by $T$, and we write $X / T$. If the morphism $\eta: X \to Y$ is mapped by $F$ to $f: T\to S$ then we say that $\eta$ lies over $f$, or $\eta$ <em>covers</em> $f$. The requirement of pullback essentially says that for every $\mathcal{X}$-family $X / T$ and a morphism $T’ \to T$ there exists another $\mathcal{X}$-family $X’ / T’$ such and such. And this pullback is essentially unique. $X’ / T’$ is said to be the pullback of $X / T$ via the continuous map $f$. We use notations \(X' = f^{\ast } X \text{ or } X' = X \mid _ {T'}.\)</p> <p>Groupoid fibration captures two notions at once:</p> <ul> <li>isomorphism of families. By the arrows in $\mathcal{X}$ (Since $\mathcal{X}$ is a groupoid).</li> <li>pullback.</li> </ul>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Frankel"/><summary type="html"><![CDATA[Disclaimer: Nothing in this note is original.]]></summary></entry><entry><title type="html">Homotopy, Extension, and some topology of SU(N)</title><link href="https://baiyangzhang.github.io/blog/2023/Homotopy-Extension-SU(N)/" rel="alternate" type="text/html" title="Homotopy, Extension, and some topology of SU(N)"/><published>2023-11-18T00:00:00+00:00</published><updated>2023-11-18T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Homotopy-Extension-SU(N)</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Homotopy-Extension-SU(N)/"><![CDATA[<p><em>Disclaimer: Nothing in this note is original.</em></p> <h2 id="homotopies-and-extensions">Homotopies and Extensions</h2> <p>The problem of extension in homotopy typically deals with the following question: given a continuous map defined on a subspace of a topological space, can it be extended to a continuous map on the entire space? Take the extension of a function on a sphere for example. Let $\mathbb{S}^{1}$ be the equator of a $\mathbb{S}^{2}$, and a continuous map $f$ define on $\mathbb{S}^{1}$: \(f: \mathbb{S}^{1} \to \mathbb{R}.\) The extension problem would be, can you find a function \(F: \mathbb{S}^{2} \to \mathbb{R}\) such that the restriction of $F$ on $\mathbb{S}^{1}$ gives $f$? The ability to extend $f$ depends on its homotopy properties. For instance, if $f$ represents a simple loop around the equator, it may or may not be extendable based on how it “wraps around” the sphere. Certain topological features of the function $f$, such as its winding number or degrees, can serve as <strong>obstructions</strong> to extending it over the entire sphere. In this particular example, $f$ is extendable to the whole sphere if it has zero winding, otherwise the non-zero winding will cause some singularity when extending it to the whole $\mathbb{S}^{2}$.</p> <hr/> <p>Now, consider a sphere of arbitrary dimension $n$, and consider it as the boundary of some $n+1$ dimensional disk $\mathbb{D}^{n+1}$ (a ball if $n&gt;0$). Let $M$ be a $n$ dimensional manifold. We have the following simple observation.</p> <p><strong>Extension Theorem.</strong> The function \(f:\mathbb{S}^{k} \to M^{n}\) is homotopic to a constant map iff $f$ can be extended to a map of the ball \(F: \mathbb{D}^{k+1} \to M.\) The proof is rather intuitive, just think of the homotopy as shrinking $\mathbb{S}^{k}$ all the way to the center of the circle.</p> <p>The extension theorem is important when discussing <strong>defects</strong>.</p> <hr/> <h2 id="covering-homotopy">Covering homotopy</h2> <p>Let $\pi: E \to M$ be a vector bundle and $f: W \to E$ be a map of a space $W$ into the bundle space $E$. Then the composition \(W \xrightarrow{f}E \xrightarrow{\pi} M\) defines a map $\overline{f}$ from $W$ to $M$, \(\overline{f} := \pi \,\circ\, f.\)</p> <p>Now, let $\overline{F}: \overline{f}\to \overline{f_ {1}}$ be a homotopy (a series of continuous functions parametrized by $t$ from $\overline{f}$ to $\overline{f_ {1}}$), we claim that we can <strong>cover the homotopy</strong> $\overline{F}$ by a homotopy of the original map $F: f\to f_ {1}$. That is, there is a map \(F: W\times [0,1] \to E\) such that for $w \in W$, \(F(w,0)=f(w),\quad F(w,1)=f_ {1}(w).\) The trick to prove the existence of covering of a homotopy is to find a way to lift the homotopy from $M$ to $E$. To be specific, consider a fixed point $w \in W$ and look at the curve \(\overline{C}:t \in [0,1] \to \overline{F}(w,t)\) in $M$. We need to find a unique lifting of $\overline{C}$ to a curve $C$ in $E$. The way to achieve that is to endow the bundle a connection $\omega$, then require $C$ to be the <strong>horizontal lift</strong>.</p> <p><em>Note that if $\overline{f}$ is homotopic to a constant map $p_ {0}$, it need not be that $f$ will be homotopic to a constant map</em>.</p> <p>What we have said for a vector bundle can also be shown to hold for a principal fiber bundle.</p> <p>It turns out that one can cover homotopies in <strong>any</strong> fiber bundle, without any use of a connection. In fact, one generalizes the notion of a fiber bundle to that of a <code class="language-plaintext highlighter-rouge">fiber space</code>. This is a space $P$ equipped with a map $\pi: P\to M$ such that <strong>homotopies can always be covered</strong>. Such spaces need not be local products.</p> <h2 id="some-topology-of-sun">Some Topology of $SU(n)$</h2> <p>$SU(n)$ is represented by $N \times N$ complex matrices acting on $\mathbb{C}^{n}$. Since each $g \in SU(N)$ is unitary, $SU(N)$ sends the unit sphere $\mathbb{S}^{2N-1} \subset \mathbb{C}^{n}$ \(\mathbb{S}^{2N-1} = \left\lbrace z \in \mathbb{C}^{N} \,\middle\vert\, \left\lvert z_ {1} \right\rvert^{2} + \dots + \left\lvert z_ {N} \right\rvert^{2}=1 \right\rbrace\) into itself. The action is also transitive (meaning any two points on $\mathbb{S}^{2N-1}$ can be connected by some group action). The isometry group for the point $(1,0,\dots,0)$ is clearly \(\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; SU(N-1) \end{bmatrix}\) which we shall briefly denote simply by $SU(N-1)$.</p> <p>We have \(\mathbb{S}^{2N-1} \cong \frac{SU(N)}{SU(2N-1)}.\)</p> <p>and in fact $SU(N)$ is a principal $SU(N − 1)$ bundle over $\mathbb{S}^{2N-1}$, with fiber at each point $p\in M$ being the little group of $p$. Thus we write \(SU(N-1)\to SU(N) \to \mathbb{S}^{2N-1}\) <strong>Theorem.</strong> If $F\to P \to M$ is a fiber bundle with connected $M$ and connected $F$, then $P$ is also connected.</p> <p>As a corollary, $SU(N)$ is connected. To see that, note $SU(1)$ is a single point, $SU(2)$ is a $3$-sphere and is connected, as are all $k$-spheres for $k\geq 3$. From \(SU(2) \to SU(3) \to \mathbb{S}^{5}\) we see that $SU(3)$ is connected. The connectness of higher $SU$ groups follow from induction.</p> <p>Another example of the above theorem is the <code class="language-plaintext highlighter-rouge">Hopf fibration</code>. The Hopf fibration is a fiber bundle where the total space $P$ is $\mathbb{S}^{3}$, the base space $M$ is $\mathbb{S}^{2}$ and the fiber $F$ is $\mathbb{S}^{1}$.</p> <hr/> <p>Recall that we say that $M$ is simply connected provided every map of a circle into $M$ is homotopic to a constant map. During the homotopy, the closed curve gets “contracted” or “deformed” to the point.</p> <p><strong>Theorem.</strong> Let $F\to P \to M$ be a fiber bundle whose fiber and base space are both simply connected. Then $P$ is simply connected.</p>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Frankel"/><summary type="html"><![CDATA[Disclaimer: Nothing in this note is original.]]></summary></entry><entry><title type="html">Higher Homotopy Groups</title><link href="https://baiyangzhang.github.io/blog/2023/Higher-Homotopy-Groups/" rel="alternate" type="text/html" title="Higher Homotopy Groups"/><published>2023-11-18T00:00:00+00:00</published><updated>2023-11-18T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Higher-Homotopy-Groups</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Higher-Homotopy-Groups/"><![CDATA[<h2 id="pi_-km">$\pi_ {k}(M)$</h2> <p>All maps considered in this chapter are supposed to be continuous.</p> <p>Consider a map $f$ from $k$-sphere to $n$-dimensional manifold $M$. We shall always ask that some distinguished point on the sphere , the “north pole”, be sent into a distinguished base point, written $\ast$ in $M^{n}$.</p> <p>For technical reasons we consider the $k$-sphere to be the $k$-cube, denoted $\mathbb{I}^{k}$. In other words \(\mathbb{I}^{k} := [0,1] \times \dots \times [0,1],\quad k\text{ of them}.\) <strong>The entire boundary $\partial \mathbb{I}^{k}$ identified with a single point</strong>, the north pole. This choice of cubic make it much easier to talk about, for example, the composition of two maps.</p> <p>We assume the reader is already familiar with the basic concepts of homotopy group, such as how we compose two elements of a homotopy group, etc.</p> <p>The commutivity that two elements of homotopy group is shown in the figure below.</p> <p><img src="/img/homotopyCommute.png" alt="commutivity"/></p> <p>Note that this procedure will not work in the case $n = 1$; there is no room to maneuver. This is why the fundamental group <strong>$\pi_ {i}$ can be nonabelian</strong>.</p> <h2 id="homotopy-groups-of-spheres">Homotopy Groups of Spheres</h2> <p>Now let’s talk about $\pi_ {k}(\mathbb{S}^{n})$. First consider the case $k&lt;N$.</p> <p>It seems evident that $f(\mathbb{S}^{k})$ cannot cover all of $\mathbb{S}^{n}$ if $k &lt; n$ but this is actually false since we <strong>do not require our maps to be smooth</strong>! Peano constructed a curve, a <strong>continuous</strong> map of the interval $[0, 1]$, whose image filled up an entire square $[0, 1] \times [0, 1]$!</p> <p>It is a fact that a continuous map of a sphere into an $M^{n}$ is homotopic (via approximation) to a smooth one. To be specific, the <strong>approximation Theorem</strong> states that any <em>continuous</em> map between <em>smooth manifolds</em> can be approximated arbitrarily closely by a smooth map. In more technical terms, for any continuous map $f$ and any $\epsilon&gt;0$, there exists a smooth map $g$ such that the distance between $f(x)$ and $g(x)$ is less than $\epsilon$ for all $x$. Hence a continuous map $f: \mathbb{S}^{k} \to M$ can be approximated by a smooth map $g$. Moreover, $f$ and $g$ are homotopic, as there exists a continuous deformation (homotopy) from $f$ to $g$. This homotopy essentially ‘smoothens’ out the irregularities in $f$ to transition it into the smooth map $g$.</p> <p>Hence we may assume that $f (\mathbb{S}^{k})$ does not cover all of $\mathbb{S}^{n}$ when $k &lt; n$. Suppose then the south pole is not covered, then we can push the image from the south pole, we can push the entire image to the north pole. We have deformed the map into a constant map. Thus \(\pi_ {k}(\mathbb{S}^{n}) =0 \text{ if } k&lt;n.\)</p> <p>Consider the case $k=n$. We know that homotopic maps of an $n$-sphere into itself have the same degree. A theorem of Heinz Hopf says in fact that maps of any <em>connected, closed, orientable</em> $n$-manifold $M$ into an $n$-sphere $\mathbb{S}^{n}$ are homotopic <em>if and only if they have the same degree</em> (the proof is nontrivial). Thus \(\pi_ {n}(\mathbb{S}^{n}) = \mathbb{Z}.\)</p> <h2 id="exact-sequences-of-groups">Exact Sequences of Groups</h2> <p>A sequence of groups and homomorphisms \(\dots \to F \xrightarrow{f} G \xrightarrow{g} H \to \dots\) are said to be <code class="language-plaintext highlighter-rouge">exact</code> at $G$ if the kernel of $G$ coincides with the image of $f$, \(\text{ker }g = \text{img }f.\) In particular, we must have that the composition $g\,\circ\,f$ is the trivial homeomorphism sending all of $F$ into the identity element of $H$. The entire sequence is said to be exact if it is exact at each group. $0$ will denote the group consisting of just the identity (if the groups are <em>not abelian</em> we usually use $1$ instead of $0$).</p> <p><strong>Some Examples.</strong></p> <p>If \(0\xrightarrow{f} H \xrightarrow{g} G\) is exact at $H$ then the image of $f$ coincides with the kernel of $g$. However the image of $0$ is the identity in $H$ alone, it means that the kernel of $g$ is the identity, nothing else. Then $g$ is injective, namely $1:1$. And since $g$ is $1:1$, we may identify $H$ with its image; in other words, we may consider $H$ to be a <em>subgroup</em> of $G$! We would simply write \(0 \to H \xrightarrow{g} G.\)</p> <p>If \(H\xrightarrow{h}G\xrightarrow{g} 0\) is exact then the image of $h$ is the kernel of $g$, which is the whole $G$. So $h$ is onto. Again we would forget about $g$.</p> <p>If \(0 \to G\xrightarrow{h}H \to{}0\) is exact, $h$ is both $1:1$ and <em>onto</em>, then $G \cong H$.</p> <p>Consider an exact sequence of three nontrivial abelian groups, the so-called <code class="language-plaintext highlighter-rouge">short exact sequence</code> \(0 \to F \xrightarrow{f}G \xrightarrow{g}H \to 0\) then the kernel of $g$ is the image of $f$, which is considered the subgroup of $G$, \(F \cong f(F) \subset G\) and $g$ is onto. Then \(H \cong \frac{G}{F}.\) <img src="/img/shortExactSequence.png" alt=""/></p> <p>If the homomorphisms involved are understood, we frequently will omit them. For example, the exact sequence \(0 \to 2 \mathbb{Z} \to \mathbb{Z} \to \mathbb{Z}_ {2} \to 0\) says that the even integers form a subgroup of the integers and \(\mathbb{Z}_ {2} \cong \mathbb{Z} / 2\mathbb{Z}.\) The exact sequence \(0 \to \mathbb{Z} \to \mathbb{R} \to \mathbb{S}^{1} \to 0\) where $\mathbb{R} \to \mathbb{S}^{1}$ is the exponential homomorphism \(r\in \mathbb{R} \mapsto \exp(i 2\pi r)\) onto the unit circle in the complex plane. Then the circle is a coset space \(\mathbb{R}^{1} \cong \mathbb{R} / \mathbb{Z}.\)</p> <p>In brief, a short exact sequence of abelian groups is always of the form \(0 \to H \to G \to G / H \to 0.\)</p> <h2 id="the-homotopy-sequence-of-a-bundle">The Homotopy Sequence of a Bundle</h2> <p>For simplicity only, we shall consider a fiber bundle with connected fiber and base.</p> <p><strong>Theorem.</strong> If the fiber $F$ is <em>connected</em>, we have the exact sequence of <em>homotopy groups</em> \(\dots \to \pi_ {k}(F)\to \pi_ {k}(P)\to \pi_ {k}(M)\xrightarrow{\partial} \pi_ {k-1}(F)\to\dots\) \(\dots \xrightarrow{\partial}\pi_ {1}(F) \to\pi_ {1}(P) \to\pi_ {1}(M)\to 1\) The homomorphism from $\pi(F)$ to $\pi(P)$ is defined by the induced map of the inclusion map $i: F \to P$. It should be clear that a continuous map $f: V \to M$ that sends base points into base points will induce a homomorphism $f_ {\star}: \pi (V)\to \pi(M)$, since a sphere that gets mapped into $V$ can then be sent into $M$ by $f$. The map from $\pi(P)$ to $\pi(M)$ is the induced map of $\pi$ the projection. The remaining <code class="language-plaintext highlighter-rouge">boundary homomorphism</code> \(\partial: \pi_ {k}(M) \to \pi_ {(k-1)}(F)\) is illustrated in the following figure for the case $k=2$.</p> <p>Consider $f:\mathbb{S}^{2} \to M$, defining an element of $\pi_ {2}(M)$. The entire boundary is mapped to $x_ {0}$.</p> <p><img src="/img/boundaryHomo.png" alt=""/></p> <p>Consider the homotopy cover of $f(\mathbb{I}^{2})$ on the bundle $P$.</p> <p><img src="/img/boundaryMap.png" alt=""/></p> <p>The above figure shows our assignment \(\partial: \pi_ {2}(M) \to \pi_ {1}(F).\) Briefly speaking, the lift of a $k$-sphere in $M$ yields a $k$-disc in $P$ whose boundary is a $(k − 1)$-sphere in $F$.</p> <p>We shall not prove exactness. Just mention that at the last stage, $\pi_ {1}(P)\to \pi_ {1}(M)$ is onto because $F$ has been assumed connected. A circle on $M$ can be lifted to a curve in $P$ whose endpoints lie in $F$ and since $F$ is connected, these endpoints can be joined in $F$ to yield a closed curve in $P$ that projects down to the original circle.</p> <h2 id="the-relation-between-homotopy-and-homology-groups">The Relation Between Homotopy and Homology Groups</h2> <p>Let $\pi_ {1}(M)$ be the fundamental group of a connected manifold $M$, we know that this group is not always abelian. A good example of this is the so-called figure-eight space, also known as the wedge sum of two circles, where the fundamental group $\pi_1$ is not abelian. The figure-eight space can be visualized as two circles touching at a single point. Let’s denote these circles as $A$ and $B$, and the point where they meet as $x_0$. The fundamental group of the figure-eight space is generated by two loops: one that goes around circle $A$ and returns to $x_0$, and another that goes around circle $B$ and returns to $x_0$. We can denote these loops as $a$ and $b$, respectively. To show that this group is not abelian, we need to demonstrate that the order in which you traverse $a$ and $b$ matters. Specifically, we need to show that $ab$ is not homotopic to $ba$, where $ab$ represents traversing loop $a$ followed by loop $b$, and $ba$ represents traversing $b$ followed by $a$. Loop $ab$ first goes around $A$ and then around circle $B$. Loop $ba$ first goes around circle $B$ and then around circle $A$. The way these loops are concatenated makes a difference. Since these loops cannot be continuously deformed into each other without breaking and rejoining at $x_0$, they represent different elements in the fundamental group. The fundamental group $\pi_1(\text{Figure-Eight}, x_0)$ is actually isomorphic to the free group on two generators, denoted $F(a, b)$. In a free group, the generators $a$ and $b$ (and their inverses) can be combined in any sequence, but there is no relation like $ab = ba$ to simplify that sequence. Therefore, the group is non-abelian.</p> <p>The key point here is that the paths $ab$ and $ba$ cannot be homotopically deformed into each other within the space of the figure-eight, making the fundamental group non-abelian.</p> <p>Let $[\pi_ {1},\pi_ {1}]$ be the subgroup of $\pi_ {1}$ generated by commutators (elements of form $bab^{-1}a^{-1}$). Then the quotient group \(\frac{\pi_ {1}}{[\pi_ {1},\pi_ {1}]} \cong H_ {1}(M,\mathbb{Z})\) where $H_ {1}(M,\mathbb{Z})$ is the first homology group.</p> <p>For the higher homotopy groups we have the <code class="language-plaintext highlighter-rouge">Hurewicz theorem</code> (Hurewicz was the inventor of these groups):</p> <p>For the higher homotopy groups we have the Hurewicz theorem (Hurewicz was the inventor of these groups), which predicts the first non-vanishing homology group from the first non-vanishing homotopy group, and vise versa.</p> <p><strong>Theorem.</strong> Let $M$ be simply connected, $\pi_ {1}=0$. Let $\pi_ {j}$ be the first non-vanishing homotopy group. Then $H_ {j}(m;\mathbb{Z})$ is the first non-vanishing homology group and those two groups are isomorphic, \(\pi_ {j}(M) \cong H_ {j}(M;\mathbb{Z}).\)</p> <p>The proof is difficult, we will just mention an example. We know $\mathbb{S}^{n}$ is simply connected for $n&gt;1$. Also, we know $H_ {j}(\mathbb{S}^{n};\mathbb{Z})$ is zero for $j&lt;n$, and $H_ {n}(\mathbb{S}^{n};\mathbb{Z})\cong\mathbb{Z}$. Thus \(\pi_ {j}(\mathbb{S}^{n}) = 0,\quad j&lt;n\) and \(\pi_ {n}(\mathbb{S}^{n})\cong \mathbb{Z}.\)</p>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Frankel"/><summary type="html"><![CDATA[$\pi_ {k}(M)$]]></summary></entry><entry><title type="html">Curvature and Winding Number</title><link href="https://baiyangzhang.github.io/blog/2023/Curvature-and-Winding-Number/" rel="alternate" type="text/html" title="Curvature and Winding Number"/><published>2023-11-16T00:00:00+00:00</published><updated>2023-11-16T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Curvature-and-Winding-Number</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Curvature-and-Winding-Number/"><![CDATA[<p><em>Disclaimer: Nothing in this note is original.</em></p> <p>We will assume that the Yang-Mills potential $\omega_ {U}$ in patch $U$ has no singularity.</p> <p>Let $\theta$ be the two-form curvature, we have the following observation for any vector bundle over all base manifolds, \(\theta \wedge \theta = (d\omega+\omega \wedge \omega)\wedge (d\omega+\omega \wedge \omega) ,\) using \(\mathrm{Tr}\,(\omega \wedge \omega \wedge d\omega) = \mathrm{Tr}\,(d\omega \wedge \omega \wedge \omega)\) and \(\mathrm{Tr}\,(\omega \wedge \omega \wedge \omega \wedge \omega)=0\) we have eventually \(\mathrm{Tr}\,(\theta \wedge \theta) = d\, \mathrm{Tr}\,\left( \omega \wedge d\omega+\frac{2}{3}\omega \wedge \omega \wedge \omega \right)\) thus $\mathrm{Tr}\,(\theta \wedge\theta)$ is <em>locally exact</em>, it is locally the differential of a $3$-form, called the <code class="language-plaintext highlighter-rouge">Chern-Simons</code> $3$-form. $\omega$ is not usually globally defined.</p> <p>Coming back to the case of instanton, outside the instanton the curvature vanishes but the connection does not, hence we have \(\int_ {U} \, \mathrm{Tr}\,(\theta \wedge \theta) = \int_ {\partial U = \mathbb{S}^{3}} \, \left( -\frac{1}{3} \right)\mathrm{Tr}\,(\omega \wedge \omega \wedge \omega).\) This allows us to write the winding number in terms of curvature, by applying some kind of Stokes theorem \(\frac{1}{24\pi^{2}}\int_ {\mathbb{S}^{3}} \, \mathrm{Tr}\,(\omega_ {U}\wedge \omega_ {U}\wedge \omega_ {U}) = - \frac{1}{8\pi^{2}} \int_ {\mathbb{R}^{4}} \, \mathrm{Tr}\,(\theta \wedge \theta).\)</p> <p>Note that $\theta \wedge\theta$ is <em>not</em> the Lagrangian, which is $\mathrm{Tr}\,(\theta \wedge\star \theta)$. We have \(\theta \wedge \theta = (\theta \wedge \theta)_ {0123}\,dt\wedge dx\wedge dy\wedge dz\propto \epsilon^{ijkl}F_ {ij}F_ {kl}\) while \(\theta \wedge \star \theta \propto F_ {ij}F^{ij}.\)</p> <h3 id="the-chern-form-for-a-un-bundle">The Chern form for a $U(n)$ bundle</h3> <p>The topological significance of $\mathrm{Tr}\,(\theta \wedge\theta)$, generalizing Poincare’s theorem for closed surfaces (which says the sum of indices times multiplicity equal to the Euler characteristic), is developed by Chern. $\mathrm{Tr}\,(\theta \wedge\theta)$ is but one of a whole family of significant integrands, called the Chern forms. But before going into details, let’s review what is <code class="language-plaintext highlighter-rouge">exterior power space</code> shortly.</p> <p>Given a vector space $V$ over a field $F$ (like the real numbers $\mathbb{R}$), the exterior algebra is an algebraic structure that extends the concept of scalars and vectors to higher-dimensional analogs. It is denoted as $\bigwedge V$. The $k$-th <code class="language-plaintext highlighter-rouge">exterior power</code> of $V$, denoted as $\Lambda^k(V)$ or $\bigwedge^{k} V$, is a vector space that consists of all alternating $k$-linear forms on $V$. For example, in $\Lambda^1(V)$, elements are just vectors. An exterior differential form of degree $k$ (or a $k$-form) on a differentiable manifold $M$ is a smooth section of the $k$-th exterior power of the cotangent bundle of $M$. In simpler terms, a $k$-form is a mathematical object that can be integrated over $k$-dimensional submanifolds of $M$. These forms are crucial in defining integrals over manifolds and in the formulation of Stokes’ theorem.</p> <p>The exterior power space $\Lambda^k(V)$ provides the algebraic structure that underlies the concept of $k$-forms. When you consider a manifold $M$ with a tangent space at each point that is a vector space $V$, the exterior power $\Lambda^k(T^\ast M)$ (where $T^\star M$ is the cotangent bundle of $M$) is the space in which exterior differential forms live. This means that each $k$-form is an element of $\Lambda^k(T^\star M)$ at each point of $M$.</p> <p><strong>Example. 1</strong></p> <p>Considering the exterior powers of a three-dimensional complex vector space $V = \mathbb{C}^3$, with basis $\lbrace v_ {1},v_ {2},v_ {3} \rbrace$. We explore the spaces formed by taking the exterior powers of $V$. These spaces are constructed using the wedge product as follows:</p> <p><em>Zeroth Exterior Power</em>, $\Lambda^0(V)$: This is the space of scalars. It is isomorphic to the field over which the vector space is defined, in this case, the complex numbers $\mathbb{C}$. The dimension of this space is one.</p> <p><em>First Exterior Power, $\Lambda^1(V)$</em>: This is just the vector space $V$ itself, with dimension three (since $V = \mathbb{C}^3$). The basis are simply $\left\lbrace v_ {1},v_ {2},v_ {3} \right\rbrace$.</p> <p><em>Second Exterior Power, $\Lambda^2(V)$</em>: This space consists of all skew-symmetric bilinear forms on $V$. It can be visualized as the space of oriented planes in $V$. It has dimension<br/> \(\binom{3}{2} = 3, \text{ since there are 3 ways to choose pairs from 3 elements.}\) The basis are $\left\lbrace v_ {1}\wedge v_ {2},v_ {1}\wedge v_ {3},v_ {2}\wedge v_ {3} \right\rbrace$.</p> <p><em>Third Exterior Power, $\Lambda^3(V)$</em>: This is the space of 3-vectors in $V$. It represents the oriented volume elements in $V$. The dimension is $\binom{3}{3} = 1$ (there is only one way to choose triples from 3 elements). The basis is $v_ {1}\wedge v_ {2}\wedge v_ {3}$.</p> <p><em>Higher Exterior Powers, $\Lambda^k(V)$ for $k &gt; 3$</em>: For any $k$ greater than the dimension of $V$ (which is 3 in this case), the exterior power $\Lambda^k(V)$ is the trivial vector space {0}, as there are no non-zero $k$-vectors in a 3-dimensional space for $k &gt; 3$.</p> <hr/> <p>Let $V=\mathbb{C}^{N}$ be $N$-dimensional complex vector space. Let $A$ be a $N\times N$ complex matrix that acts on $V$ in the usual way. Consider the<code class="language-plaintext highlighter-rouge"> characteristic (eigenvalue) polynomial</code> of $A$, \(\det(\lambda I-A) = (\lambda-\lambda_ {1})(\lambda-\lambda_ {2})\dots(\lambda-\lambda_ {N})\) where $\lambda_ {1},\dots,\lambda_ {N}$ are the eigenvalues of $A$. Putting $\lambda=-1$ we have \(\begin{align*} \det(I+A) &amp;= (1+\lambda_ {1})(1+\lambda_ {2})\dots(1+\lambda_ {N}) \\ &amp;= 1 + \sum_ {i}\lambda_ {i} + \sum_ {i&lt;j} \lambda _ {i} \lambda _ {j} +\dots+\prod_ {i=1}^{N}\lambda_ {i} \\ &amp;= 1 + \mathrm{Tr}\,A + \mathrm{Tr}\, \bigwedge^{2}A +\dots+\mathrm{Tr}\,\bigwedge^{N}A \end{align*} \tag{1}\) where the big wedges are called the <code class="language-plaintext highlighter-rouge">elementary symmetric functions</code> of he eigenvalues of $A$. The reason for this notation is as follows. Since \(A: V \to V\) is a linear transformation on $V$, we may let $A$ act on each of the <em>exterior power spaces</em> $\Lambda^{p} (A)$ by the so-called <em>exterior power operation</em> \(\bigwedge^{p}A: \; v_ {1}\wedge \dots \wedge v_ {p} \mapsto (Av_ {1})\wedge (Av_ {2})\wedge \dots \wedge (Av_ {p} ).\) Let’s take $p=N$ for example. $\Lambda^{N}(V)$ is one dimensional and \(\left( \bigwedge^{N}A \right)(v_ {1}\wedge \dots \wedge v_ {n} ) = \det A\, (v_ {1}\wedge \dots \wedge v_ {n} ).\) Thus justifies the definition shown in the last term in Eq. (1). Let’s take a look at other terms, for example, at $\Lambda^{2}A$. We treat $A$ as diagonal matrix $\text{diag}(\lambda_ {1},\dots,\lambda_ {N})$ to simplify the calculation, and we can consider \(\bigwedge^{2}(v_ {i}\wedge v_ {j})\) as the component of the exterior power operator on basis $v_ {i}\wedge v_ {j}$. Then the trace of $\Lambda^{2}(A)$ is simply the sum total of all its components. We have \(\bigwedge^{2}(v_ {i}\wedge v_ {j}) = A_ {im} A_ {jn}(v_ {m} \wedge v_ {n} ) = (\lambda _ {i} \lambda _ {j})\, v_ {i} \wedge v_ {j}\) where $i&lt;j$ implicitly. Then the total sum is \(\mathrm{Tr}\,\bigwedge^{2} A = \sum_ {i&lt;j}\lambda _ {i} \lambda _ {j} .\)</p> <hr/> <p>It turns out we can further simplify $\Lambda^{p}A$. Note that \(\lambda_ {1}^{p} + \lambda_ {2}^{p} + \dots + \lambda _ {N}^{p} = \mathrm{Tr}\,(A^{p}),\quad A = \text{diag}(\lambda_ {1},\dots,\lambda_ {N}).\)</p> <p>Take $p=2$ for example, \(\bigwedge^{2} A = \sum _ {i&lt;j} \lambda _ {i} \lambda _ {j} = \frac{1}{2} \sum_ {ij} \lambda _ {i} \lambda _ {j} - \frac{1}{2} \lambda _ {i} \lambda _ {i} = \frac{1}{2}(\mathrm{Tr}\,A)^{2} - \frac{1}{2} \mathrm{Tr}\,A^{2}.\)</p> <p>Turns out all the exterior power operators can be expressed as a <em>polynomial</em> in terms of $\mathrm{Tr}\, A^{n}$ and $(\mathrm{Tr}\,A)^{m}$ for some $m$ and $n$.</p> <hr/> <p>Now, let $E\to M$ be a complex $\mathbb{C}^{N}$ bundle with structure group $U(N)$. Let the connection be $\omega$. The corresponding $2$-form curvature is still denoted by $\theta$.</p> <p>Let’s <em>formally</em> replace $A$ in Eq. (1) with $i\theta / 2\pi$, replace multiplication with wedge product. To be exact, we work with <strong>polynomial expression</strong> of $\Lambda^{p}A$, and perform these substitutions. Since $\theta$ is a $2$-form there will be no problem with ordering. Regarding $\theta$ as a matrix means that the $(\alpha,\beta)$-th entry of the matrix is $\theta^{\alpha}_ {\;\; \beta}$. Now similar to Eq. (1) we have \(\begin{align*} \det \left( I+\frac{i\theta}{2\pi} \right) &amp;= I + \mathrm{Tr}\,\frac{i\theta}{2\pi} + \dots \\ &amp;= I + c_ {1}(E) + c_ {2}(E) + \dots \end{align*}\) where $c_ {1}(E)$ is a 2-form on $U\subset M$, $c_ {r}(E)$ is a $2r$-form on $U$. It’s called the $r$-th <code class="language-plaintext highlighter-rouge">Chern form</code>.</p> <p>To be specific, the form $c_ {1}$ is \(c_ {1} = \frac{i}{2\pi} \mathrm{Tr}\,\theta = \frac{i}{2\pi} \mathrm{Tr}\,\theta^{\alpha}_ {\;\; \alpha}.\) For $c_ {2}$ we have \(c_ {2} = -\frac{1}{8\pi^{2}}[\mathrm{Tr}\,\theta \wedge \mathrm{Tr}\,\theta-\mathrm{Tr}\,(\theta \wedge \theta)].\)</p> <p>Suppose the bundle has $SU(N)$ structure group rather than $U(N)$. The Lie algebra ${\frak su}(N)$ are traceless, anti-hermitian (mathematical convention) matrices, thus we have $\mathrm{Tr}\,\theta=0$ (recall that both the connection and curvature are ${\frak g}$-valued forms). Then $c_ {1}(E)$ vanishes but $c_ {2}$ does not, \(c_ {2}(E) = \frac{1}{8\pi^{2}} \mathrm{Tr}\,(\theta \wedge \theta),\) which is precisely the 4-form appearing in the winding number of an $SU(2)$ instanton! Just now we have $SU(N)$ instead.</p> <p>Recall that the curvature $\theta_ {U}$ is locally defined on open patches $U$, under a change of basis the curvature changes as \(\theta_ {V} = c_ {VU} \theta_ {U} c_ {UV}^{-1} ,\) thanks to the property of determination we have \(\det\left( I+ \frac{i \theta_ {V}}{2\pi} \right) = \det\left( I+ \frac{i\theta_ {U}}{2\pi} \right).\) It means that each <em>Chern form</em> is <strong>globally define</strong> $2r$-form on all of $M^{n}$.</p> <p>With the help of Bianchi identity, it is possible to show that $c_ {1}$ is closed.</p> <p>For $SU(2)$ bundle, the second Chern form is <em>locally</em> the differential of Chern-Simons form.</p> <p>We present without proof the</p> <p><strong>Theorem of Chern and Weil:</strong> Each $c_ {r}$ is a <em>closed</em> $2r$-form thus defines a (real) de Rham class. Furthermore, different connections for the $U(N)$ bundle will yield Chern form that differs by an exact form, and hence define the same de Rham cohomology class.</p>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Frankel"/><category term="#Topology"/><summary type="html"><![CDATA[Disclaimer: Nothing in this note is original.]]></summary></entry><entry><title type="html">Introduction to Transseries</title><link href="https://baiyangzhang.github.io/blog/2023/Transseries-Lecture/" rel="alternate" type="text/html" title="Introduction to Transseries"/><published>2023-11-08T00:00:00+00:00</published><updated>2023-11-08T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Transseries-Lecture</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Transseries-Lecture/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>In history, formal power series are used extensively for finding the resolution of differential equations. If the resulting power series is convergent, it gives rise to a germ which can be analytically continued to (multi-valued) functions on a Riemann surface. However, very often, the power series we found from solving a differential equation is divergent, then it is not clear <em>a prior</em> how to attach reasonable sums to them.</p> <p>The modern theory of <code class="language-plaintext highlighter-rouge">resummation</code> was developed systematically by Stieltjes, Borel and Hardy, who invented some resummation methods which <em>are stable under the common operators of analysis</em>. Later, Poincare established the equivalence between computations with formal power series and asymptotic expansions. Newton, Borel and Hardy were all aware of the systematic aspects of their theories and they consciously tried to complete their framework so as to capture as much of analysis as possible. The great unifying theory nevertheless had to wait until the late 20-th century and Ecalle’s work on transseries and Dulac’s conjecture.</p> <hr/> <p>Transseries have found significant applications in various areas of physics, particularly in high-energy physics. They are employed as algebraic tools to investigate self-consistent Dyson–Schwinger equations, which are integral equations that arise in the field of quantum field theory, specifically in Yukawa theory and quantum electrodynamics <a href="https://www.sciencedirect.com/science/article/pii/S0003491616300793">1</a>. These equations are pivotal in understanding the interactions of particles and fields at a fundamental level.</p> <p>In the realm of general relativity, transseries are applied to asymptotic analysis. General relativity stands as one of the cornerstones of modern physics, governing the laws of gravitation and the dynamics of large-scale structures in the universe . By applying transseries in this domain, researchers can gain insights into the asymptotic behavior of gravitational fields and the dynamics of spacetime.</p> <p>Furthermore, transseries are used in the <em>extraction of non-perturbative physics from perturbation theory through resurgence and alien calculus</em>. Perturbation theory is a fundamental tool in quantum mechanics and quantum field theory, allowing for the approximation of complex systems. The non-perturbative effects are those that cannot be captured by perturbation theory alone, and transseries help to identify and understand these effects <a href="https://www.sciencedirect.com/science/article/pii/S0003491619301691">2</a>..</p> <p>Additionally, in the context of integrable, asymptotically free field theories, transseries have applications in studying the free energy of such systems when coupled to a conserved charge. These studies are significant in high-energy physics, particularly in understanding the thermodynamics and statistical mechanics of particle systems <a href="https://link.springer.com/article/10.1007/JHEP08%282022%29279">3</a>.</p> <p>These examples showcase the versatility and importance of transseries in advancing the understanding of fundamental physics, from the microscale of particle interactions to the macroscale of cosmic phenomena.</p> <p>I hope the information provided has sparked your interest in transseries. Now, let’s delve into the subject itself.</p> <hr/> <p>Define a ordered group ${\frak G}$ (frak G) of transmonomials. Define a differential field $\mathbb{T}$ of <code class="language-plaintext highlighter-rouge">transseries</code>. Transmonomials are generalizations of monomials in polynomials, by including exponential and logarithmic. In this note and that follows, we will consider the limit where $x\to \infty$.</p> <p>Let’s start with exponents first.</p> <p><strong>Log-free transmonomials.</strong> They are of form \(x^{b}e^{ L },\quad b\in \mathbb{R},\; L \in \text{large log-free transseries.}\)</p> <p>For example, the following are all log-free transmonomials, \(x^{-1},\; x^{\pi}x^{x^{\sqrt{ 2 }}-3x},\; e^{ \sum_ {i}x^{-1}e^{ x } },etc.\)</p> <p>The multiplication is defined in the obvious way. The group identity is just $1$.</p> <p>We define a binary relation $\gg$, read “far larger than”. Keep in mind that we assumed $x\to \infty$. So how does this “far larger than” work? We compare the exponents $e^{ L }$ first, whichever with the largest exponent $L$ is far larger than others; if they have same exponents, then we compare the power of $x$, namely $x^{b}$, whichever with larger $b$ is far larger then others. To be specific, \(x^{b_ {1}}e^{ L_ {1} } \gg x^{b_ {2}}e^{ L_ {2} }\quad \text{ if } L_ {1} &gt; L_ {2} \;\lor\; (L_ {1}=L_ {2}\;\land\; b_ {1}&gt;b_ {2} ),\) where $\lor$ is logic or. For example, $x^{-5}\gg x^{20}e^{ -x }$ since $x^{-5}=x^{-5}e^{ 0 }$ and $0&gt;-x$.</p> <p><strong>Log-free transseries.</strong> A log-free transseries $T$ is a formal sum of log-free monomials ${\frak g}$, \(T = \sum_ {i} c_ {i} {\frak g}_ {i},\quad c_ {i} \in \mathbb{R} .\) We require the order of transmonomials be such that, each ${\frak g_ {i}}$ is far smaller than all previous terms, namely they appear in descending orders. This is similar to the case of regular polynomials where we usually put the highest powers at first.</p> <p>The transseries $T$ is said to be <code class="language-plaintext highlighter-rouge">purely large</code> if all transmonomials ${\frak g}_ {i}$ are far larger than $1$ (not $0$), namely ${\frak g_ {i}}\gg 1 \;\forall i$. $T$ is said to be <code class="language-plaintext highlighter-rouge">small</code> if all ${\frak g}_ {i}\ll 1$ (why isn’t it called purely small?). The largest (in the sense of far larger than) transmonomial is called the <code class="language-plaintext highlighter-rouge">dominant term</code>, let’s call it $c_ {0}{\frak g}_ {0}$. If the dominant term has positive coefficients, $c_ {0}&gt;0$, then $T$ is said to be positive. This enables us to compare the size of two transseries $S,T$, we say $S&gt;T$ if $S-T&gt;0$. So we just need to compare their dominant terms.</p> <hr/> <p>We consider only transmonomials and transseries of “finite exponential height”. For example, we don’t want \(e^{ x^{x^{x\dots}} }.\)</p> <p>The <code class="language-plaintext highlighter-rouge">differentiation</code> of $T$ with respect to $x$ is defined the usual way.</p> <hr/> <p>Next let’s include logarithmic. $\log$ acting $m$ times is denoted $\log_ {m}x$ or $\log_ {(m)}x$, namely \(\log_ {(m)}x = \log \dots \log x,\quad m\; \log .\)</p> <p>A general transseries is obtained by substitution of some $\log_ {m}x$ for $x$ in a log-free transseries.</p> <p><em>Every nonzero transseries has a multiplicative inverse.</em> This is similar to formal power series.</p> <p><em>A lot of functions can now be regarded as a transseries</em>. For example, e hyperbolic sine is a two-term transseries.</p> <h2 id="formal-constructions">Formal Constructions</h2> <p>In mathematics, the move towards higher levels of formality entails adopting rigorous and precise language, definitions, and proofs, which brings clarity and precision, ensuring that mathematical concepts are universally understood and applied correctly. It allows for the development of solid, gap-free proofs, having a deeper understanding of mathematical structures and providing a robust foundation for complex theories. This precision in communication is critical in a global context, where scientists from different fields rely on universally recognized formalisms to understand each other effectively.</p> <p>However, this precision comes at a cost. It can make the subject less accessible to beginners (like myself), potentially hindering educational and interdisciplinary work. A focus on stringent formalism might even inhibit creative thinking, as the rigidity of formal proofs could constrain the exploratory, intuitive processes that often drive mathematical discovery. Moreover, the lengthy and detailed nature of formal proofs can make mathematical work less efficient, both in terms of personal understanding and communication with others. There’s also the risk of diminishing intuition, which is a crucial aspect of mathematical thought, particularly in the preliminary stages of research. It is definitely crucial to have a balance between concrete examples and general formalism, what is I hope to achieve in this note.</p> <hr/> <p>The set of monomials ${\frak G}$ form a field, which is also a group if we focus on multiplication alone. ${\frak G}$ is <em>not</em> finitely generated, to see this consider the finitely generated group with generator \(\mu_ {1},\mu_ {2},\dots,\mu_ {n},\) the generated group has elements of form \(\left\{ \mu_ {1}^{k_ {1}}\times \mu_ {2}^{k_ {2}}\times \dots \times \mu_ {n}^{k_ {n}} \,\middle\vert\, k_ {1},\dots,k_ {n} \in \mathbb{Z} \right\} .\) Note that the exponents must be integers.</p> <p>Let’s use capital letters to denote a set of indices, for example define \(K := (k_ {1},k_ {2},\dots,k_ {n})\) then \(\mu_ {1}^{k_ {1}}\dots \mu_ {n}^{k_ {n}} =: \mu^{K}.\)</p> <p>This will save some writing. The problem is that $\mu^{K}$ can also be interpreted as $\mu^{k_ {1}k_ {1}\dots k_ {n}}$, but it should be clear from the context.</p>]]></content><author><name>Baiyang Zhang</name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Note on Numerical Methods in Solving ODE</title><link href="https://baiyangzhang.github.io/blog/2023/Notes-on-Numerical-Methods-in-Solving-ODE/" rel="alternate" type="text/html" title="Note on Numerical Methods in Solving ODE"/><published>2023-10-31T00:00:00+00:00</published><updated>2023-10-31T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Notes-on-Numerical-Methods-in-Solving-ODE</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Notes-on-Numerical-Methods-in-Solving-ODE/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>In my line of work I sometimes need to solve unsolvable ODEs and PDEs, unsolvable in the sense that it is impossible to get an analytical solution. What we do is to turn to numerical methods for help. For instance, just recently I need to solve a modified version of the Skyrme equation (the equation of motion resulted from the Skyrme model). I thought it would be helpful to summarize what I’ve learnt here.</p> <p>Various numerical methods have been developed to tackle different types of ODEs (initial value problems, boundary value problems, linear, nonlinear, etc.). Here are some of the most popular numerical methods for solving ODEs:</p> <ol> <li><strong>Euler’s Method</strong>: <ul> <li>This is the simplest one-step method.</li> <li>It’s based on a linear approximation of the solution.</li> <li>While straightforward and instructive for educational purposes, it’s rarely used in practice due to its low accuracy and stability issues.</li> </ul> </li> <li><strong>Runge-Kutta Methods</strong>: <ul> <li>These are a family of iterative methods.</li> <li>The 4th order Runge-Kutta (often called RK4) is particularly popular due to its balance between accuracy and computational cost.</li> </ul> </li> <li><strong>Leapfrog (or Midpoint) Method</strong>: <ul> <li>A second-order method that is particularly useful in cases where energy conservation is crucial, such as in molecular dynamics simulations.</li> </ul> </li> <li><strong>Predictor-Corrector Methods</strong>: <ul> <li>These methods predict a solution using an explicit method and then correct it with an implicit method.</li> <li>Examples include the Adams-Bashforth (predictor) and Adams-Moulton (corrector) methods.</li> </ul> </li> <li><strong>Backward Differentiation Formulas (BDF)</strong>: <ul> <li>These are implicit multi-step methods.</li> <li>Commonly used for stiff ODEs.</li> </ul> </li> <li><strong>Multistep Methods</strong>: <ul> <li>These methods use values at multiple previous time steps.</li> <li>Examples include the Adams methods.</li> </ul> </li> <li><strong>Symplectic Integrators</strong>: <ul> <li>These are used for Hamiltonian systems where preserving the symplectic structure (related to conservation of energy) is essential.</li> </ul> </li> <li><strong>Implicit Methods</strong>: <ul> <li>Used frequently for stiff equations where explicit methods require prohibitively small time steps.</li> <li>Examples include the backward Euler method and the trapezoidal rule.</li> </ul> </li> <li><strong>Shooting Method</strong>: <ul> <li>Primarily used for boundary value problems (BVPs).</li> <li>Converts a BVP into an initial value problem (IVP) and then solves the IVP.</li> </ul> </li> <li><strong>Relaxation Methods</strong>: <ul> <li>Also for boundary value problems.</li> <li>Iteratively refines an initial guess to the solution.</li> </ul> </li> <li><strong>Finite Difference Method</strong>: <ul> <li>Converts differential equations into <em>difference</em> equations, which can then be solved algebraically.</li> <li>Often used for both ODEs and PDEs.</li> </ul> </li> <li><strong>Collocation Methods</strong>: <ul> <li>This approach seeks an approximate solution by considering values at specific points (collocation points).</li> </ul> </li> <li><strong>Continuation method</strong>, which we will go to detail later.</li> </ol> <hr/> <p>These methods can be adapted or combined in various ways depending on the specific problem at hand. Moreover, the choice of method often depends on the nature of the ODE (e.g., stiffness), desired accuracy, computational cost considerations, and the specific properties that need to be preserved (e.g., conservation laws).</p> <p>Many modern computational packages and software (like MATLAB, Mathematica, and SciPy in Python) provide built-in functions that implement these methods, which makes it easier for users to solve ODEs without delving deeply into the numerical intricacies of each method.</p> <p><strong>Stiffness.</strong></p> <p>Imagine you’re on a winding road with both smooth curves and sharp turns. If you’re driving a car along this road at a constant speed, the smooth curves can be navigated quite easily, but the sharp turns require more caution and precision.</p> <p>Similarly, in the context of differential equations, there can be parts of the solution that change very slowly (smooth curves) and others that change extremely rapidly (sharp turns). When a differential equation has solutions with widely differing rates of change over its domain, we say that the equation is “stiff.” When you’re solving a stiff differential equation using numerical methods (like the Euler method or the Runge-Kutta method), you’ll notice that the rapid changes require very small step sizes for accurate solutions. However, the slow-changing parts don’t need such small steps. If you choose a step size suitable for the rapidly changing sections (very small), the computation can become inefficient because you’re using more steps than necessary for the slow-changing sections. On the other hand, if you choose a larger step size suitable for the slow-changing sections, the solution can become unstable or highly inaccurate in the rapidly changing sections.</p> <p>To efficiently and accurately solve stiff differential equations, specialized numerical methods have been developed, known as “stiff solvers.” These solvers are designed to adaptively handle the challenges posed by stiffness, allowing for stable and efficient computation.</p> <h2 id="numerical-values-of-parameters">numerical values of parameters</h2> <p>I collected the following values from the Adkins:Nappi:1984 paper<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>,<br/> \(m_ {\pi} = 108 \text{ MeV}, \quad e=4.82,\quad F_ {\pi} = \frac{m_ {\pi}}{0.263 e}\) which gives us \(\begin{align} m_ {1} &amp;= 0.526, \\ m_ {2} &amp;= 1.052. \end{align}\)</p> <p>In the chiral case, pion is massless and we have \(\begin{align} m_ {1} &amp;= 0, \\ m_ {2} &amp;= 1.052. \end{align}\)</p> <h2 id="the-shooting-method">The shooting method</h2> <p>The shooting method is a numerical technique used to solve boundary value problems (BVPs) for ordinary differential equations (ODEs). <em>It’s especially useful for second-order ODEs, but can be applied to higher-order equations as well</em>.</p> <p>Here’s a basic overview of the shooting method:</p> <p><strong>The Problem:</strong> Suppose you have a second-order ODE given as: \(y''(x) = f(x, y, y'),\) with boundary conditions: \(y(a) = y_ a\) \(y(b) = y_ b\)</p> <p><strong>The Challenge:</strong> Directly solving the BVP using typical ODE solvers is difficult because standard solvers require initial conditions (values of $y$ and $y’$ at a starting point), rather than boundary conditions at two separate points.</p> <p><strong>The Shooting Method’s Approach:</strong></p> <ol> <li> <p><strong>Guess an Initial Slope</strong>: Choose an initial guess for the derivative $y’(a)$, let’s call it $y’_ a$.</p> </li> <li> <p><strong>Solve as an IVP</strong>: Using the known value $y(a) = y_ a$ and the guessed $y’(a) = y’_ a$ then solve the ODE as an initial value problem (IVP) over the interval $[a, b]$ using standard techniques, like the Runge-Kutta method.</p> </li> <li> <p><strong>Check the Endpoint</strong>: Once you’ve solved the ODE using your initial guess, check the value of $y(b)$ from this solution. Compare it to the desired boundary condition $y_ b$.</p> </li> <li> <p><strong>Adjust the Guess</strong>: If $y(b)$ from your solution is close to $y_ b$, then you’re done. If not, adjust your guess for $y’(a)$ and solve the IVP again. This is typically done using a root-finding algorithm like Newton’s method or the secant method.</p> </li> <li> <p><strong>Iterate</strong>: Repeat steps 2-4 until $y(b)$ from your solution is sufficiently close to $y_ b$, or until a set number of iterations have been reached.</p> </li> </ol> <p>The method’s name comes from the idea that you’re “shooting” from one boundary towards the other. Your first “shot” might miss the target (the second boundary condition). By adjusting your aim (the initial derivative guess) and shoot again, you try to hit the target. The process is repeated until you’re close enough to the target, similar to adjusting one’s aim when firing at a target in marksmanship.</p> <p>While the shooting method can be effective, it’s not guaranteed to work for all BVPs, especially when the underlying ODEs are highly nonlinear or when appropriate initial guesses are hard to ascertain. Unfortunately, the solving of the modified Skyrme equation seems to fall in the category, as I am about to go to details right now.</p> <p>With the parameters listed in the previous chapter, I tried to solve the equation of motion using shooting method with the following codes</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bc1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Pi</span><span class="p">;</span>
<span class="n">bc2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">approximateSolution</span> <span class="o">=</span> <span class="n">Pi</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Tanh</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

<span class="n">initialGuessY</span> <span class="o">=</span> 
  <span class="n">approximateSolution</span> <span class="p">/</span><span class="o">.</span> 
   <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">;</span>  <span class="p">(</span><span class="o">*</span><span class="n">Evaluate</span> <span class="n">approximate</span> <span class="n">solution</span> <span class="n">at</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="p">)</span>
<span class="n">initialGuessYPrime</span> <span class="o">=</span> 
  <span class="n">D</span><span class="p">[</span><span class="n">approximateSolution</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="p">/</span><span class="o">.</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">;</span>  <span class="p">(</span><span class="o">*</span><span class="n">Evaluate</span> <span class="n">derivative</span> <span class="n">at</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="p">)</span>

<span class="n">shootingMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Shooting"</span><span class="p">,</span> 
   <span class="s2">"StartingInitialConditions"</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initialGuessY</span><span class="p">,</span> 
   <span class="n">f</span><span class="o">'</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initialGuessYPrime</span><span class="p">}};</span>

<span class="n">solutionTest1</span> <span class="o">=</span> <span class="n">Module</span><span class="p">[{</span><span class="err">$$</span><span class="n">Eta</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="mf">0.526</span><span class="err">`</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="mf">1.052</span><span class="err">`</span><span class="p">},</span>
	 <span class="n">shootingMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Shooting"</span><span class="p">,</span> 
    <span class="s2">"StartingInitialConditions"</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Pi</span><span class="p">,</span> <span class="n">f</span><span class="o">'</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">}};</span>
  <span class="n">NDSolve</span><span class="p">[{</span><span class="n">eom</span><span class="p">,</span> <span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">},</span> <span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">},</span> <span class="n">PrecisionGoal</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="p">,</span> 
   <span class="n">AccuracyGoal</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="p">]]</span>
</code></pre></div></div> <p>where eom is short for the equation of motion, given by \(\begin{align} \text{eom} =&amp;-2 r^4 f''(r)-4 \eta r^2 f''(r) \sin ^2(f(r))+4 \eta r^3 f'(r)^3-4 r^3 f'(r)^3-4 r^3 f'(r)-2 \eta r^2 f'(r)^2 \sin (2 f(r)) \\ &amp;+6 \eta r^4 f'(r)^2 f''(r)-6 r^4 f'(r)^2 f''(r)+2 \text{m1}^2 r^4 \sin (f(r))+2 \text{m2}^2 r^4 \sin (f(r)) \\ &amp;-\text{m2}^2 r^4 \sin (2 f(r))+2 r^2 \sin (2 f(r))+\sin (2 f(r))-\sin (2 f(r)) \cos (2 f(r)) \\ &amp;==0. \end{align}\) However the computation takes a long time and yields a nonsensical result, <img src="/img/eom.png" alt=""/></p> <p>which doesn’t make any sense.</p> <hr/> <p>For the following discussions, I found paper <a href="https://arxiv.org/abs/1309.1313">arXiv:1309.1313</a> to be most helpful. Below are some approximation we can adopt at $r\to 0$, \(\frac{\sin(f(r))}{r} \to f'(0), \quad \frac{1}{4}-\frac{\sin^2(f(r))}{r^2} -(f'(r))^2 \to \frac{1}{4}\) \(\frac{r^2}{4} + 2\sin^2(f(r)) = \frac{r^2}{4}\left( 1+8\frac{\sin^2(f(r))}{r^2} \right) \to \frac{r^2}{4}(1+8f'(0)).\)</p> <p>Maybe we can make it work by providing a super accurate initial condition? With this hope I try to solve the equation at the origin, close to $r=0$. Expand $f(r)$ about the origin we get \(f(r) = f(0) + r f'(r) = \pi + rg(r),\quad g(r) := f'(r)\) where we have made use of the initial condition that $f(0)=\pi$, and $r$ is supposed to be very small. Take this to the equation of motion, with some manipulation we get \(\left(-4 r^4 g^{2}(r)-2 r^4\right) g'(r)-2 m_ 1^2 r^5 g(r)-4 m_ 2^2 r^5 g(r)-4 r^3 g^{3}(r) =0\) keep the leading order and NLO in $r$ we have \(\left(2 r g^{2}(r)+r\right) g'(r)+2 g^{3}(r)=0\) In paper arXiv:hep-ph/0106150v2, Ponchiano etc. adopted Pade approximation and it seems to be working good. But it’s not directly useful to me.</p> <p>Well let’s move on to the next method.</p> <h2 id="the-continuation-homotopy-embedding-method">The continuation (homotopy, embedding) method</h2> <p>The core idea behind the “continuation method” is that, instead of trying to solve a super-hard problem right away, we start with a simpler version of it that we can solve. Then, we “continue” from that solution, making small changes step by step, until we reach the solution of the original, harder problem.</p> <ol> <li><strong>Start Simple</strong>: Begin with a version of the problem that’s easy to solve.</li> <li><strong>Make Small Changes</strong>: Adjust the problem little by little, using the solution from the last step as the starting point for the next.</li> <li><strong>Reach the Target</strong>: Continue this process until you’ve transformed your simple problem’s solution into a solution for your original, harder problem.</li> </ol> <p>Let us apply the aforementioned philosophical ideas into practice. Suppose we wish to solve a system of $N$ non-linear equations in $N$ variables, say \(F(x) = 0,\quad F: \mathbb{R}^{n} \to \mathbb{R}^{n}.\) We assume $F$ is $C^{\infty}$. Suppose that we don’t know a lot about the initial value of the derivative, then we can’t effectively adopt the shooting method. As a possible remedy, define a homotopy or deformation $H(x,t)$ which deforms from some simpler equations $G(x)$ to $F(x)$ when $t$ smoothly changes, to be specific define \(H(x,0) = G(x),\quad H(x,1) = F(x).\) Everything is required to be smooth here. Typically, one can choose a so-called <code class="language-plaintext highlighter-rouge">convex homotopy</code> such as \(H(x,t) = t\,F(x) + (1-t)\, G(x).\) $H(x,t)$ is the function we are trying to solve. Our job is to find $G(x)$ with known solution, then the PDE that $H(x,t)$ satisfies, offer the initial condition, then try to solve it.</p> <p>Let’s look at an example. Let’s solve the following non-linear partial differential equation, which is a simplified version of the Ginzburg-Landau equation, a fundamental equation in superconductivity theory: \(\frac{\partial u}{\partial t} = \nabla^2 u + \lambda u - u^3\)</p> <p>Here, $u(x, y, t)$ is the field we want to solve for, $\nabla^2 u$ is the Laplacian operator, $\lambda$ is a parameter, and $t$ represents time.</p> <p>Let’s consider a square domain $[0, L] \times [0, L]$ with periodic boundary conditions. We will solve this equation using the continuation method by gradually increasing the parameter $\lambda$ and using the solution from the previous value of $\lambda$ as the initial condition for the next one.</p> <p>This following code defines the PDE and its boundary conditions, then solves it using <code class="language-plaintext highlighter-rouge">NDSolve</code> for a range of values of $\lambda$, starting from $\lambda = 0$ and going up to $\lambda = 1$. The solution for each value of $\lambda$ is used as the initial condition for the next one. Finally, it plots the solution for $\lambda = 1$.</p> <p>Here is the Mathematica code:</p> <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Define the domain size *)</span><span class="w">
</span><span class="nv">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the grid size *)</span><span class="w">
</span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="o">;</span><span class="w">
</span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the time step and final time *)</span><span class="w">
</span><span class="nv">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01</span><span class="o">;</span><span class="w">
</span><span class="nv">tmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the initial condition *)</span><span class="w">
</span><span class="nv">u0</span><span class="p">[</span><span class="nv">x</span><span class="o">_,</span><span class="w"> </span><span class="nv">y</span><span class="o">_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[(</span><span class="nb">Pi</span><span class="o">*</span><span class="nv">x</span><span class="p">)</span><span class="o">/</span><span class="nv">L</span><span class="p">]</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[(</span><span class="nb">Pi</span><span class="o">*</span><span class="nv">y</span><span class="p">)</span><span class="o">/</span><span class="nv">L</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the PDE *)</span><span class="w">
</span><span class="nv">pde</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="p">}]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="p">}]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">λ</span><span class="o">*</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">^</span><span class="m">3</span><span class="o">;</span><span class="w">

</span><span class="c">(* Solve the PDE using the continuation method *)</span><span class="w">
</span><span class="err">λ</span><span class="nv">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Range</span><span class="p">[</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">0.1</span><span class="p">]</span><span class="o">;</span><span class="w">
</span><span class="nv">usol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="o">;</span><span class="w">
</span><span class="nv">uinit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u0</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span><span class="o">;</span><span class="w">
</span><span class="nb">For</span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nb">Length</span><span class="p">[</span><span class="err">λ</span><span class="nv">values</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="err">λ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">λ</span><span class="nv">values</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">;</span><span class="w">
  </span><span class="nv">sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NDSolve</span><span class="p">[{</span><span class="nv">pde</span><span class="o">,</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">uinit</span><span class="o">,</span><span class="w"> 
    </span><span class="nb">PeriodicBoundaryCondition</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nb">TranslationTransform</span><span class="p">[{</span><span class="nv">L</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="p">}]]</span><span class="o">,</span><span class="w">
    </span><span class="nb">PeriodicBoundaryCondition</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nb">TranslationTransform</span><span class="p">[{</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}]]}</span><span class="o">,</span><span class="w">
   </span><span class="nv">u</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">t</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">}</span><span class="o">,</span><span class="w"> 
   </span><span class="nb">Method</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"MethodOfLines"</span><span class="o">,</span><span class="w"> </span><span class="s">"SpatialDiscretization"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"TensorProductGrid"</span><span class="o">,</span><span class="w"> </span><span class="s">"MaxPoints"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="nv">nx</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="p">}}}]</span><span class="o">;</span><span class="w">
  </span><span class="nb">AppendTo</span><span class="p">[</span><span class="nv">usol</span><span class="o">,</span><span class="w"> </span><span class="nv">sol</span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="nv">uinit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">]</span><span class="w"> </span><span class="o">/.</span><span class="w"> </span><span class="nv">sol</span><span class="o">;</span><span class="w">
</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Plot the solution for λ = 1 *)</span><span class="w">
</span><span class="nv">sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">usol</span><span class="p">[[</span><span class="o">-</span><span class="m">1</span><span class="p">]]</span><span class="o">;</span><span class="w">
</span><span class="nb">Plot3D</span><span class="p">[</span><span class="nb">Evaluate</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">]</span><span class="w"> </span><span class="o">/.</span><span class="w"> </span><span class="nv">sol</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nb">AxesLabel</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="o">,</span><span class="w"> </span><span class="s">"y"</span><span class="o">,</span><span class="w"> </span><span class="s">"u"</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div> <p>But before getting our hands dirty let’s consider another similar but different method, for reasons I’ll explain later.</p> <h2 id="the-relaxation-method">The relaxation method</h2> <p>The term “relaxation” refers to the idea that an initial guess at the solution is iteratively refined or “relaxed” until it converges to the true solution.</p> <p><strong>Introduction to the Relaxation Method:</strong></p> <p>The relaxation method is often used for solving elliptic PDEs, such as Laplace’s equation and Poisson’s equation. The general approach of the relaxation method is as follows:</p> <ol> <li>Discretize the domain of the PDE into a grid or mesh.</li> <li>Make an initial guess for the solution at each grid point.</li> <li>Iteratively update the solution at each grid point using a numerical approximation of the PDE.</li> <li>Repeat step 3 until the solution converges to within a specified tolerance.</li> </ol> <p>Let’s consider an example of solving Laplace’s equation on a rectangular domain $[0, a] \times [0, b]$ with Dirichlet boundary conditions.</p> <p>Laplace’s equation is given by: \(\nabla^2 u(x, y) = 0\)</p> <p>Where $u(x, y)$ is the function we are trying to solve for, and $\nabla^2$ is the Laplacian operator.</p> <p>For simplicity, let’s consider the case where $a = b = 1$, and the boundary conditions are: \(u(0, y) = 0, \quad u(1, y) = 0, \quad u(x, 0) = 0, \quad u(x, 1) = \sin(\pi x)\)</p> <p>Here are the steps to solve this problem using the relaxation method in Mathematica:</p> <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Define the domain size *)</span><span class="w">
</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">
</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the grid size *)</span><span class="w">
</span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">
</span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the boundary conditions *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Table</span><span class="p">[</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">j</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">j</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[</span><span class="nb">Pi</span><span class="o">*</span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="o">/</span><span class="nv">nx</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the relaxation parameter *)</span><span class="w">
</span><span class="nv">omega</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.5</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the tolerance for convergence *)</span><span class="w">
</span><span class="nv">tol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="m">6</span><span class="p">)</span><span class="o">;</span><span class="w">

</span><span class="c">(* Perform the relaxation iteration *)</span><span class="w">
</span><span class="nv">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">;</span><span class="w">
</span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">
</span><span class="nb">While</span><span class="p">[</span><span class="nv">error</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">tol</span><span class="o">,</span><span class="w">
  </span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">;</span><span class="w">
  </span><span class="nb">For</span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">nx</span><span class="o">,</span><span class="w"> </span><span class="nv">i</span><span class="o">++,</span><span class="w">
    </span><span class="nb">For</span><span class="p">[</span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">ny</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="o">++,</span><span class="w">
      </span><span class="nv">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="o">;</span><span class="w">
      </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">omega</span><span class="p">)</span><span class="o">*</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">omega</span><span class="o">*</span><span class="m">0.25</span><span class="o">*</span><span class="p">(</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">]])</span><span class="o">;</span><span class="w">
      </span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Max</span><span class="p">[</span><span class="nv">error</span><span class="o">,</span><span class="w"> </span><span class="nb">Abs</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">old</span><span class="p">]]</span><span class="o">;</span><span class="w">
    </span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="nv">iteration</span><span class="o">++;</span><span class="w">
</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Display the result *)</span><span class="w">
</span><span class="nv">u</span><span class="w">
</span></code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">u</code> matrix contains the approximate solution to the PDE at each grid point. The <code class="language-plaintext highlighter-rouge">While</code> loop continues iterating until the maximum change in the solution at any grid point is less than the specified tolerance <code class="language-plaintext highlighter-rouge">tol</code>.</p> <p>The relaxation method is a powerful and widely used numerical technique for solving PDEs. It is particularly well-suited for solving elliptic PDEs, such as Laplace’s equation and Poisson’s equation, which arise in various physical applications. The method is relatively simple to implement and can be easily adapted to different types of PDEs and boundary conditions.</p> <p>However, it’s important to note that the convergence of the relaxation method can be sensitive to the choice of the relaxation parameter <code class="language-plaintext highlighter-rouge">omega</code> and the grid size. In some cases, it may be necessary to experiment with different values of these parameters to achieve a satisfactory solution.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Nuclear Physics B233 (1984) 109-115, doi: 10.1016/0550-3213(84)90172-x <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Baiyang Zhang</name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">The Fundamental Group and Covering Spaces</title><link href="https://baiyangzhang.github.io/blog/2023/The-Fundamental-Group-and-Covering-paces/" rel="alternate" type="text/html" title="The Fundamental Group and Covering Spaces"/><published>2023-10-30T00:00:00+00:00</published><updated>2023-10-30T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/The-Fundamental-Group-and-Covering%20-paces</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/The-Fundamental-Group-and-Covering-paces/"><![CDATA[<p><em>Disclaimer: Nothing in this note is original.</em></p> <p>Let $\gamma$ be a loop with base point $p_ {0}$, on a connected (not necessarily simply connected) maniofld $M$. This circle is a map \(\gamma: [0,1]\to M,\quad \gamma(0)=\gamma(1)=p_ {0}.\) Consider all such loops with the same base point. Recall that if we can deform one loop to another in a continuous fashion while preserving the base point, we say they are homotopic, \(\gamma_ {1} \sim \gamma_ {2}.\) If some loop $\gamma$ is homotopic to a point, or a constant, then we call it trivial and write \(\gamma \sim 1.\)</p> <p>Note the requirement that the base point must be fixed, sometimes it happens that a loop can be shrink to a point if you are allowed to move it around in the manifold, but if you have to fix a base point then it is no longer true. Hence, sometimes a loop is <code class="language-plaintext highlighter-rouge">homologically</code> trivial but not homotopically trivial.</p> <p>Given two loops $\gamma_ {1}$ and $\gamma_ {2}$ on M, by reparameterization (so that each loop is traversed with double speed) we may compose them to give a new loop, which is traditionally written from left to right, for example $\gamma_ {1}\gamma_ {1}(\theta)$ means traverse along $\gamma_ {1}$ first then $\gamma_ {2}$. This defines the <em>“multiplication”</em> of loops. This multiplication is defined up to homotopy, under which the loops form a group structure. This is the <code class="language-plaintext highlighter-rouge">fundamental group</code> of $M$, written \(\pi_ {1}(M; p_ {0}).\)</p> <p>If we don’t care about the base point, then we simply write \(\pi_ {1}(M).\)</p> <p>Recall that, by definition, a space is <code class="language-plaintext highlighter-rouge">simply connected</code> if all loops are contractible to a point, that is, if the group $\pi_ {1}(M)$ consists only of the identity.</p> <p>Some famous example include that $\pi_ {1}(S_ {1})=\mathbb{Z}$, $\pi_ {1}(SO(3))=\mathbb{Z}_ {2}$, etc.</p> <hr/> <p><strong>Covering space</strong></p> <p>We shall say that a connected space $\overline{M}$ is a covering of the connected $M$, with covering or projection map \(\pi: \overline{M} \to M,\) if each $x\in M$ has a neighborhood $U$ such that the preimage $\pi ^{-1}(U)$ consists of <em>disjoint open</em> subsets $\left{ U_ {\alpha} \right}$ of $\overline{M}$, each <em>diffeomorphic</em> under $\pi$.</p> <p>For example, we can cover $\mathbb{S}^{1}$ with $\mathbb{R}$ infinite times.</p> <p>The notion of covering space can also be described in terms of fiber bundles as follows:</p> <p>A covering space of a manifold $M$ is a connected space $\overline{M}$ that is a fiber bundle over $M$ with fiber $F$ a discrete set of points.</p> <p>Let $M$ be a connected manifold. The universal covering manifold $\overline{M}$ of $M$ is a covering space that has trivial fundamental group.</p> <hr/> <p>Let $\gamma,\gamma_ {1}$ be two paths form $p_ {0}$ to $p$. An orientable covering is such that if when we translate an orientation along the closed curve $\gamma\gamma ^{-1}$ we return with the original orientation. It is important that we are dealing with homotopy classes: if a closed curve $C$ preserves orientation, and if $C’$ is homotopic to $C$, then $C’$ will also preserve orientation.</p> <p>An orientable covering is in general smaller than the universal covering, but not necessarily.</p> <p>By the same arguments, it can be shown in general that the orientable cover of $M$ is either $M$ itself, if $M$ is orientable, or a 2-sheeted cover of $M$. As an example, a two-sheeted-orientable cover of the Klein bottle is the torus!</p> <p><strong>Lifting paths</strong></p> <p>Given a covering $\pi: \overline{M} \to M$, the lift of a path $\gamma$ in $M$ is roughly speaking a continuous path $\overline{\gamma}$ in $\overline{M}$ whose projection $\pi(\overline{M})$ is $\gamma$ itself.</p> <p>By definition of the universal cover, the points of the fiber $\pi ^{-1}(p_ {0}), p_ {0}\in M$ are in $1:1$ correspondence with the distinct homotopy classes of closed curves in $M$ starting at $p_ {0}$. Summarizing,</p> <p><strong>Theorem.</strong> The universal cover $\overline{M}$ of $M$ is simply connected and the number of sheets in the covering is equal to the number of elements (the <code class="language-plaintext highlighter-rouge">order</code>) of $\pi ^{-1}(p_ {0})$.</p> <p>If a manifold is not orientable, there is some closed curve that reverses orientation. We have the following explanation of the terminology that we have been using:</p> <p><strong>Theorem.</strong> The orientable cover of $M$ is always orientable. The number of sheets is $1$ if $M$ is orientable and $2$ if $M$ is not orientable.</p> <hr/> <p>In homotopy group $\pi_ {1}(M)$, there sometimes exists properties that can be used to define subgroups of $\pi_ {1}$. For example, if $M$ is not orientable, then two curves $\gamma,\gamma_ {1}$ in <em>different</em> homotopy class may preserve the orientation or not. $\gamma$ and $\gamma_ {1}$ may both preserve the orientation, then they belong to the same subgroup of $\pi_ {1}$ that is defined to be the loops that preserve the orientation. The identity of this subgroup is the equivalence class of all the loops that preserves the orientation, while the other element is the class of loops that flip the orientation, if you are in doubt just think of loops on a Mobius strip.</p> <p>There is a relation between the subgroups of $\pi_ {1}$ and the covering space. Given any subgroup $G$ of $\pi_ {1}$, we may associate a covering space $M_ {G}$ of $M$ as follows: We again consider pairs $p\in M,\gamma$, and we identify $(p,\gamma)$ with $p,\gamma_ {1}$ iff the homotopy class of the loop $\gamma \gamma_ {1}^{-1}$ lies in the subgroup $G$.</p> <hr/> <p>What happens if we put universal covering space with Lie group? After all Lie groups are nothing but manifolds themselves. It is more or less intuitive that, for a Lie group $G$, its universal covering space is itself another Lie group $\overline{G}$. For example, $SO(3)\cong \mathbb{R}P^{3}$ is a Lie group, its universal covering space is $SU(2)\cong \mathbb{S}^{3}$, which is another Lie group.</p>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Frankel"/><summary type="html"><![CDATA[Disclaimer: Nothing in this note is original.]]></summary></entry><entry><title type="html">Bi-invariant Forms on Compact Groups</title><link href="https://baiyangzhang.github.io/blog/2023/Bi-invariant-Forms-on-Compact-Groups/" rel="alternate" type="text/html" title="Bi-invariant Forms on Compact Groups"/><published>2023-10-29T00:00:00+00:00</published><updated>2023-10-29T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Bi-invariant-Forms-on-Compact-Groups</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Bi-invariant-Forms-on-Compact-Groups/"><![CDATA[<p><em>Disclaimer: Nothing in this note is original.</em></p> <h2 id="bi-invariant-forms-on-compact-groups">Bi-invariant Forms on Compact Groups</h2> <p>Recall that a form or vector field on $G$ is said to be bi-invariant if it is both left and right invariant.</p> <p><strong>Theorem.</strong> if $\alpha$ is a bi-invariant $p$-form, then $p$ is closed, \(d \alpha=0.\) Recall that the Maurer-Cartan form is defined as \(\Omega := g^{-1} dg\)</p> <p>The Maurer-Cartan form is a $\mathfrak{g}$-valued 1-form defined on a Lie group $G$, where $\mathfrak{g}$ is the Lie algebra of $G$. The Maurer-Cartan form encodes the local structure of the Lie group, and it is used to translate between the geometry of the Lie group and the algebra of its Lie algebra.</p> <p>If $G$ is a Lie group and $g \in G$, the Maurer-Cartan form $\Omega$ at $g$ is a linear map from the tangent space $T_gG$ of $G$ at $g$ to the Lie algebra $\mathfrak{g}$ of $G$:</p> \[\Omega_g : T_gG \rightarrow \mathfrak{g}.\] <p>Now, let $v$ be a $\mathfrak{g}$-valued vector field on $G$. Then the action of the Maurer-Cartan form on $v$ is given by \(\Omega(v) : G \rightarrow \mathfrak{g},\)\(g \mapsto \Omega_g(v_g),\) where $v_g$ is the value of the vector field $v$ at $g \in G$.</p> <p>The Maurer-Cartan form has the property that it is left-invariant, i.e., for any $g, h \in G$, we have \(\Omega_{gh} = \mathrm{Ad}(h^{-1}) \cdot \Omega_g,\) where $\mathrm{Ad}$ is the adjoint representation of the Lie group $G$. This reflects the relationship between the geometry of the Lie group and the algebraic structure of its Lie algebra.</p> <p>we can also define the <code class="language-plaintext highlighter-rouge">Cartan p-form</code> \(\Omega_ {p} := \mathrm{Tr}\, \Omega^{p} =\mathrm{Tr}\,\left\{ \Omega \wedge \dots \wedge \Omega \right\} .\) Cartan p-forms are scalar forms with very special properties, 1) they are bi-invariant hence closed, 2) $\Omega_ {2p}=0$ automatically. We will neglect the proof here.</p> <p>The Cartan 3-form plays an especially important role. Since $\Omega(X)=X$ for all $X\in{\frak g}$, we have \((\Omega \wedge \Omega)(X,Y) = \Omega(X)\otimes \Omega(Y) - \Omega(Y)\otimes \Omega(X)=[X,Y],\) When $G$ is compact we have \(\Omega^{3}(X,Y,Z) = 3\mathrm{Tr}\,([X,Y]Z).\)</p> <hr/> <p><strong>Bi-invariant Riemannian Metrics</strong></p> <p>Let $\left\langle -,- \right\rangle$ be the scalar product in ${\frak g}$ that is Ad invariant. The existence of an invariant scalar product is closely related to the concept of compactness for Lie groups. If a Lie group is compact, then it is possible to average any bilinear form on the Lie algebra over the group to obtain an invariant scalar product. This averaging process relies on the existence of a normalized Haar measure, which exists for compact groups. However, if the Lie group is not compact, such a Haar measure does not exist in general, and hence the averaging process cannot be carried out in the same way. As a result, there is no guarantee that a non-compact Lie group will have an invariant scalar product on its Lie algebra. That said, it is possible for non-compact Lie groups to have invariant scalar products on their Lie algebras, but this is not guaranteed, and it depends on the specific properties of the group and its algebra.</p> <p><strong>Theorem.</strong> There is a bi-invariant Riemannian metric on every compact Lie group</p> <p><strong>Theorem.</strong> In any bi-invariant metric on a group, the geodesics are the 1-parameter subgroups and their translates.</p> <p>As a result, in a group with a bi-variant Riemann metric, a geodesic through $e$ with tangent velocity $X$ is given by $e^{ tX }$.</p> <p>One says that a Riemannian manifold $M^{n}$ is <code class="language-plaintext highlighter-rouge">geodesically complete</code> if every geodesic starting anywhere $C(0)\cdot e^{ tX }$ exists for all real value of $t$. It is a fact that if $M$ is compact then it is automatically geodesically complete. Furthermore</p> <p><strong>Hopf-Rinow Theorem.</strong> If $M^{n}$ is geodesically complete, then any pair of points on $G$ can be joined with a geodesic of minimal length.</p> <p>For a proof of these facts see Milnor’s book.</p> <p>In a compact group $G$ we may introduce a bi-invariant metric, and then the 1- parameter subgroups are geodesics. Thus</p> <p><strong>Theorem.</strong> Every point in a compact connected Lie group G lies on at least one 1-parameter subgroup.</p> <hr/> <p>There is a theorem saying that, in a <em>bi-invariant metric</em> on a <em>compact</em> connected Lie group $G$, the bi-invariant forms coincide with the harmonic forms.</p> <p>We will skip the proof here, just mention that it will make use of the fact that the Hodge dual $\star$ commutes with left and right translations $R_ {g\ast}, L_ {g\ast}$.</p> <p><strong>Bi-invariant forms are harmonic in the bi-invariant metric!</strong></p> <hr/> <p>The <code class="language-plaintext highlighter-rouge">center</code> of a group $G$ is the <em>subgroup</em> $Z$ of elements that commute with all the elements of the group. For example, the center of $U(N)$ is $e^{ i\theta }\mathbb{1}_ {N}$, the center of $SU(N)$ is the $n$ scalars $\lambda$ such that $\lambda^{i}=1,\;i=1,\dots,N$.</p> <p><strong>Weyl’s Theorem.</strong> Let $G$ be a compact connected group. Then the first Betti number vanishes, $b_ {1}(G) = 0$, iff the center of $G$ does not contain any $1$-parameter subgroup.</p> <p>In particular, $b_ {1}=0$ for $SU(N)$ but not for $U(N)$.</p> <p>The following plays an important role in gauge theories,</p> <p><strong>Cartan’s Theorem.</strong> If $G$ is a <em>compact</em>, <em>nonabelian</em> Lie group, then the Cartan $3$-form \(\Omega_ {3} = \mathrm{Tr}\,(g^{-1} dg g^{-1} dg g^{-1} dg)\) is a non-trivial harmonic form. In particular $b_ {3}(G)\neq 0$.</p> <h2 id="the-geometry-of-a-lie-group">The Geometry of a Lie Group</h2> <p>Let $G$ be a Lie group endowed with a bi-invariant metric (which exist on every compact Lie group). Let $\mathbf{X},\mathbf{Y},\mathbf{Z},\dots$ be left-invariant vector fields. In a compact Lie group, geodesics are also 1-parameter subgroups and vise versa, so \(\nabla_ {\mathbf{X}}\mathbf{X}=0.\) Like wise, \(\nabla_ {\mathbf{X}+\mathbf{Y}}(\mathbf{X}+\mathbf{Y}) \implies 2\nabla_ {\mathbf{X}}\mathbf{Y}=[\mathbf{X},\mathbf{Y}].\)</p> <p>The center of a Lie algebra ${\frak g}$ is defined to be the elements $\mathbf{X}$ of ${\frak g}$ such that $[\mathbf{X},\mathbf{Y}]=0$ for all $\mathbf{Y}\in{\frak g}$.</p> <p><strong>Weyl’s Theorem.</strong> Let $G$ be a compact Lie group with bi-invariant metric. Suppose that the center of $G$ is trivial, then $G$ is compact and has a finite fundamental group $\pi_ {1}(G)$.</p>]]></content><author><name>Baiyang Zhang</name></author><category term="Geometry"/><category term="Minkowski"/><category term="Frankel"/><summary type="html"><![CDATA[Disclaimer: Nothing in this note is original.]]></summary></entry><entry><title type="html">The Poincare Duality</title><link href="https://baiyangzhang.github.io/blog/2023/Poincare-Duality/" rel="alternate" type="text/html" title="The Poincare Duality"/><published>2023-10-26T00:00:00+00:00</published><updated>2023-10-26T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Poincare-Duality</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Poincare-Duality/"><![CDATA[<h3 id="simplicial-vs-singular-complex">Simplicial vs. Singular complex</h3> <p>I put it here not because it is really related to our discussion about Poincare duality, just because I was confused and need to make some note somewhere. If you are only interested in Poincare duality please jump to the second part directly.</p> <p>A singular complex and a simplicial complex are both concepts from algebraic topology to study a space, however, they are used in different contexts and have some key differences:</p> <p>Simplicial complex is a collection of simplices (points, line segments, triangles, and their n-dimensional analogues) that are glued together in a certain way. The collection must satisfy two conditions:</p> <ol> <li>Every face of a simplex in the collection is also in the collection.</li> <li>The intersection of any two simplices in the collection is either empty or a face of both.</li> </ol> <p>On the other hand, a singular complex is not a collection of simplices, but a collection of singular simplices, which are continuous maps from the standard simplex to a topological space. Singular simplices can be used to study the topology of any space, not just those that can be decomposed into simplices.</p> <p>Simplicial complexes are used in situations where <em>a space can be nicely decomposed into simplices</em>. They are useful in the study of homology and cohomology, as well as in computational topology. Meanwhile, singular complexes are used to define singular homology and cohomology, which <em>can be applied to any topological space</em>, including those that can’t be nicely decomposed into simplices. Singular homology and cohomology are more general than their simplicial counterparts.</p> <p>A simplicial complex has a clear geometric representation as a collection of simplices glued together. On the contrary, a singular complex doesn’t have as clear a geometric representation since it consists of maps from simplices to a space, rather than the simplices themselves. Simplicial complexes are less flexible than singular complexes since they can only be used to study spaces that can be decomposed into simplices</p> <p>In summary, a simplicial complex is a collection of simplices glued together in a specific way, while a singular complex is a collection of continuous maps from the standard simplex to a topological space. Simplicial complexes have a clear geometric representation and are useful in studying spaces that can be decomposed into simplices, while singular complexes are more flexible and can be used to study any topological space.</p> <h2 id="poincares-duality">Poincare’s Duality</h2> <h3 id="introduction">Introduction</h3> <p>Poincaré duality is a fundamental and profound concept in algebraic topology, bridging homology and cohomology, two primary tools we use to probe the topological structure of a manifold. This relationship can provide a richer understanding of the manifold’s geometry and topology.</p> <p>In simple terms, Poincaré duality tells us that for a <em>compact</em>, <em>orientable</em> manifold $M$ of dimension $n$, the $k$-th homology group of $M$ is isomorphic to the $(n-k)$-th cohomology group. Mathematically, this is represented as: \(H_ k(M; \mathbb{Z}) \cong H^{n-k}(M; \mathbb{Z}).\) To truly appreciate Poincaré duality, we must first have a solid grasp of some core concepts in algebraic topology.</p> <p><strong>1. Homology:</strong></p> <ul> <li>Homology provides a way to associate algebraic objects, called homology groups, to topological spaces. These groups capture the essence of “holes” in the space at different dimensions. For example, the $0$-th homology group measures the number of connected components, the $1$-st homology group captures loops, and the $2$-nd homology group represents cavities or voids in the space.</li> </ul> <p><strong>2. Cohomology:</strong></p> <ul> <li>Cohomology, similar to homology, assigns algebraic objects, cohomology groups, to a topological space. However, instead of measuring “holes,” cohomology groups measure the ways in which functions can be integrated over these “holes.” Algebraically speaking, cohomology is a linear operation that turns the elements of homology into numbers.</li> </ul> <p>Now, let’s delve deeper into Poincaré duality. For a compact, orientable $n$-dimensional manifold $M$, we can consider a $k$-dimensional cycle $Z$ (which represents an element of the $k$-th homology group) and a $(n-k)$-dimensional cohomology class $\omega$. Poincaré duality states that we can pair $\omega$ with $Z$ to produce a number, and this pairing is <em>non-degenerate</em>. In simpler terms, for each non-zero $k$-dimensional cycle, there exists a $(n-k)$-dimensional cohomology class that “detects” it, and vice versa.</p> <p>Poincare duality has profound implications for the study of manifolds. It tells us that <em>the topology of a manifold at small dimensions reflects its topology at large dimensions</em>. This symmetry provides an elegant and powerful tool for understanding the manifold’s structure.</p> <p>In our upcoming sections, we will explore the details.</p> <h4 id="review-of-homology">Review of homology</h4> <p><em>Induced homomorphism in homology</em></p> <p>In homology theory, an induced homomorphism is a function between homology groups that is naturally derived from a continuous function between topological spaces. In other words, if you have a <strong>continuous</strong> function $f: X \to Y$ between two topological spaces $X$ and $Y$, then this function will “induce” a homomorphism $f_ *: H_ n(X) \to H_ n(Y)$ between the homology groups of $X$ and $Y$.</p> <p>The induced homomorphism has the following properties:</p> <ol> <li><strong>Functoriality:</strong> <ul> <li>If $f: X \to Y$ and $g: Y \to Z$ are continuous functions, then $(g \circ f)_ \ast = g_ \ast \circ f_ \ast$.</li> <li>If $id_ X: X \to X$ is the identity function, then $(id_ X)_ \ast = id_ {H_ n(X)}$.</li> </ul> </li> <li><strong>Preservation of Homologous Cycles:</strong> <ul> <li>If two cycles are homologous in $X$, then their images under $f_ *$ will be homologous in $Y$.</li> </ul> </li> </ol> <p>Mathematically, if $f: X \to Y$ is a continuous map, then for each non-negative integer $n$, there is an induced homomorphism: \(f_ \ast: H_ n(X) \to H_ n(Y)\) The induced homomorphism is defined by taking a homology class $[z]$ in $H_ n(X)$ and mapping it to the homology class $[f(z)]$ in $H_ n(Y)$, where $f(z)$ is the image of the cycle $z$ under the map $f$. This can be expressed as: \(f_ \ast([z]) = [f(z)]\) The concept of induced homomorphisms allows us to study how the topological properties of spaces are related through continuous functions.</p> <p><strong>Relative homology groups</strong></p> <p>The notation $H_ k(M, N; R)$ denotes the $k$-th relative homology group of a pair of topological spaces $(M, N)$ with coefficients in a ring $R$. Here, $M$ is a topological space, $N$ is a subspace of $M$, and $R$ is a ring (commonly $\mathbb{Z}$ for integer coefficients or $\mathbb{Q}$ for rational coefficients).</p> <p>Relative homology groups are a generalization of homology groups that allow us to study the topology of a space relative to a subspace. The $k$-th relative homology group $H_ k(M, N; R)$ measures the $k$-dimensional holes in $M$ that are not in $N$, with the homology classes represented with coefficients in the ring $R$.</p> <p>The definition of the $k$-th relative homology group involves the following steps:</p> <ol> <li> <p><strong>Chain Complex:</strong> Consider the chain complex of $M$ and the chain complex of $N$ with coefficients in $R$. These are sequences of $R$-modules and boundary homomorphisms that capture the $k$-dimensional simplices in $M$ and $N$, respectively.</p> </li> <li> <p><strong>Quotient Chain Complex:</strong> Form the quotient chain complex $C_ k(M, N; R) = C_ k(M; R) / C_ k(N; R)$.</p> </li> <li> <p><strong>Boundary Homomorphisms:</strong> Define boundary homomorphisms $\partial_ k: C_ k(M, N; R) \to C_ {k-1}(M, N; R)$ on the quotient chain complex.</p> </li> <li> <p><strong>Homology Group:</strong> Finally, the $k$-th relative homology group $H_ k(M, N; R)$ is the quotient group of cycles modulo boundaries in the quotient chain complex.</p> </li> </ol> <h3 id="mikio-nakaharas-approach">Mikio Nakahara’s approach</h3> <p>In Nakahara’s textbook, he approached Poincare duality (Chapter 6, <em>DE RHAM COHOMOLOGY GROUPS</em>) as the following.</p> <p>First he defined the “standard” version of everything, a standard space is just an Euclidean space $\mathbb{R}^{n}$, a standard n-simplex is a generalization of a triangle to n-dimensional space. To define it more formally, a standard $n$-simplex is a set of points ${v_ 0, v_ 1, \ldots, v_ n}$ in $\mathbb{R}^{n+1}$ such that:</p> <ol> <li>Each $v_ i$ is a standard basis vector. This means that it has a 1 in the $i$-th coordinate, and 0 in every other coordinate. For example, in $\mathbb{R}^3$, the second standard basis vector is $(0, 1, 0)$.</li> <li>The convex hull of these points is the standard $n$-simplex. Mathematically, this is defined as: \(\overline{\sigma}_ {r} := \left\{\sum_ {i=0}^n t_ i v_ i \,\mid \, \sum_ {i=0}^n t_ i = 1 \text{ and } 0 \leq t_ i \leq 1 \text{ for all } i\right\}.\)</li> </ol> <p>Here are a few examples of standard simplices:</p> <ul> <li>The standard 0-simplex is a single point.</li> <li>The standard 1-simplex is a line segment.</li> <li>The standard 2-simplex is an equilateral triangle.</li> <li>The standard 3-simplex is a regular tetrahedron.</li> </ul> <p>Then Nakahara goes on to define the integral of a n-form on a standard n-simplex. Here you don’t need to worry about things such as orientation, volume element (without $\sqrt{ \left\lvert g \right\rvert }$ since is it trivial), nice and simple. He uses <em>singular</em> instead of <em>simplicial</em> complex to study the topology of a manifold $M$. After defining the <em>chains, cycles and boundaries</em> (the basic building blocks of homology), Nakahara defined what a homology group is. It is just the classes of cycles up to boundaries, \(B_ {r}(M;\mathbb{R}) := Z_ {r}(M;\mathbb{R}) / B(M;\mathbb{R})\) where $\mathbb{R}$ denotes the coefficient of the homology group, could be replaced by $\mathbb{Z}_ {2}$ or other groups.</p> <p>Recall that Nakahara defined standard simplex $\overline{\sigma}$ and a generic, non-standard simplex $\sigma$ (without the bar) on $\mathbb{R}^{n}$. Mapping continuously a generic simplex $\mathbb{R}^{n}$ to $M$ you have the singular simplex on $M$, singular since the map might be without a inverse. Now we can do integral not only on r-simplexes on $\mathbb{R}^{n}$ but also on r-chains on the manifold $M$, by pulling back the form to be integrated on $M$ to $\mathbb{R}^{n}$, then make use of the linearity of integrals. By the end of the first section, Nakahara introduced the Stokes’ theorem.</p> <p>In the second section about de Rham cohomology, Nakahara first introduced counterparts of cycles and boundaries of differential forms, namely \(\text{cycles} \longleftrightarrow \text{cocycyles = closed forms}\) and \(\text{boundaries} \longleftrightarrow \text{coboundaries = exact forms.}\)</p> <p>The boundaries also form vector spaces with $\mathbb{R}$-coefficients. Then the de Rham cohomology group was introduced as the quotient \(H^{r} (M; \mathbb{R}) = \text{Closed forms} / \text{Exact forms}.\)</p> <p>All this could be better illustrated using a complex chain maybe, but that’s not Nakahara’s approach, maybe considering the physics backgrounds of the readers. By the end of the section he introduced the de Rham’s theorem, which we already covered in another note under the name “de Rham …”.</p> <p>In section 6.3, Nakahara introduces a lemma that can help to decide when is a closed form also exact, we have already covered this again in another note talking about Poincare’s <code class="language-plaintext highlighter-rouge">potential</code>. Roughly speaking, on a patch $U\subset M$, if $U$ is contractible to a point, then a closed form defined on it is exact. <em>Any closed form is exact at least locally.</em> The de Rham cohomology group is regarded as an obstruction to the global exactness of closed forms.</p> <p>In section 6.4, Nakahara starts with Poincare duality, which is the topic of our note today. We will take more time to explain it here.</p> <hr/> <p>Let $M$ be a $m$-dimensional <em>compact</em> m-dimensional manifold and let $\omega \in H^{r}(M)$ and $\eta \in H^{m-r}$. Noting that $\omega \wedge \eta$ is a volume element, so we can construct an inner product \(\left\langle \omega,\eta \right\rangle := \int _ {M} \, \omega \wedge \eta.\) The inner product $\left\langle -,- \right\rangle$ is a map that takes an element from $H^{r}$ and $H^{m-r}$ to a number. This map is both linear (obviously) and non-singular, meaning that if $\omega \neq 0$ then $\left\langle \omega,\eta \right\rangle$ can’t be zero for all $\eta$. That makes the relation between $H^{r}$ and $H^{m-r}$ a <code class="language-plaintext highlighter-rouge">duality</code>.</p> <p>According to Nakahara, this is called the <code class="language-plaintext highlighter-rouge">Poincare duality</code>. The problem is that, the Poincare duality defined here is between two cohomology groups, in the meanwhile the Poincare duality I read about from somewhere else is between homology and cohomology, between $H_ {r}$ and $H^{m-r}$. Maybe the missing connection between $H_ {r}$ and $H^{r}$ is given by the de Rham theorem? To answer this I’ll keep reading Hatcher’s textbook.</p> <hr/> <p>After introducing the Poincare duality, Nakahara introduces the cohomology ring where the role of production is played by wedge. Note that this is a ring regarding cohomology, not the differential forms themselves. This is one big difference between homology and cohomology, that we can define a sensible product for cohomology but not for homology. But I am not sure if this statement only applies to de Rham cohomology or to any cohomology.</p> <p>At the end of this chapter, Nakahara talked about Kunneth formula, which tells</p>]]></content><author><name>Baiyang Zhang</name></author><category term="math"/><category term="quantum"/><category term="field"/><category term="theory"/><category term="confinement"/><summary type="html"><![CDATA[Simplicial vs. Singular complex]]></summary></entry><entry><title type="html">Introduction to Higher Form Symmetry</title><link href="https://baiyangzhang.github.io/blog/2023/Introduction-to-Higher-Form-Symmetry-Lecture-3/" rel="alternate" type="text/html" title="Introduction to Higher Form Symmetry"/><published>2023-10-23T00:00:00+00:00</published><updated>2023-10-23T00:00:00+00:00</updated><id>https://baiyangzhang.github.io/blog/2023/Introduction-to-Higher-Form-Symmetry%20Lecture%203</id><content type="html" xml:base="https://baiyangzhang.github.io/blog/2023/Introduction-to-Higher-Form-Symmetry-Lecture-3/"><![CDATA[<p>For conventions used in this note, see my blog <a href="http://www.mathlimbo.net/2022/07/17/Conventions-and-Formula/">here</a>.</p> <p>In lecture 2 we have talked about classic symmetry and their re-interpretation using the language of differential (exterior) form. We have made the connection between the so-called symmetry defect operator (SDO) and a charged, point operator. In this note we try to generalized this concept to charged operators defined on manifolds of dimension more than zero, that is, a line, a surface, etc.</p> <p>Let’s start with the ordinary symmetry once again. Recall that we have written the variation of the action as \(\delta S = \int d^{D-1}x \, J^{\mu}\partial_ {\mu}\epsilon(x) \tag{1}\) where $\xi$ is the parameter of the symmetry transformation, under which the charged operators transform as \(\phi(x) \to \epsilon(x) \Delta \phi(x).\) In our convention, $\Delta$ stands for a small but finite change while $\epsilon(x)$ stands for an infinitesimal function. Eq. (1) can be regarded as the definition of the Noether current $J^{\mu}$, which tells us how much the action changed under the transformation in question. But, being a symmetry of the system, of course the action remains unchanged, hence the conservation of the charge \(\partial_ {\mu}J^{\mu} = 0 \Longleftrightarrow d\star J=0.\)</p> <p>In the language of differential forms, we can regard $\epsilon$ as a $0$-form, which is (by definition) a function. Then the variation of action reads \(\delta S = \int_ {M^{(D)}} (\star J)\wedge d\epsilon, \tag{2}\) where $\star J$ is a $(D-1)$-form, $d \epsilon$ is a $1$-form (since $\epsilon$ is a zero form), hence their wedge product is a $D$-form, something can be integrated over $D$-dimensional manifold $M$ (whose boundary is $\Sigma$).</p> <p>The advantage of Eq. (2) is that it can be generalized to higher forms. Assume $\epsilon$ is a 1-form now. Then $d \epsilon$ is a 2-form, as a result $\star J$ is a $(D-2)$-form and $J$ is a $2$-form. The conservation law becomes \(d \star J = 0 \to \partial_ {\mu} J^{\mu \nu}=0.\) Since $(D-2)$-form can be integrated over a $(D-2)$ manifold, we can define the charge operator as \(Q(\Sigma_ {D-2}):= \int_ {\Sigma} \, \star J.\)</p>]]></content><author><name>Baiyang Zhang</name></author><category term="PureMath"/><category term="Notes"/><summary type="html"><![CDATA[For conventions used in this note, see my blog here.]]></summary></entry></feed>