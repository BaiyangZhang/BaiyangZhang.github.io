<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Tsallis Statistics in Logistic Regression | Baiyang Zhang</title> <meta name="author" content="Baiyang Zhang"> <meta name="description" content="A place dedicated to sharing insights and reflections on mathematics, physics, and social sciences. "> <meta name="keywords" content="mathematics, physics, academic-website, portfolio-website"> <script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } });
    </script> <script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
			skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			inlineMath:  [ ['$',  '$'],  ["\\(","\\)"]  ],
			displayMath: [ ['$$','$$'],  ["\\[","\\]"]  ],
			tags: 'ams', // This enables automatic equation numbering
			tagSide: 'right', // Position of equation numbers, 'left' or 'right'
			tagIndent: '0.8em', // Indentation of equation numbers from the margin
		}
	});
	</script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/z.png?010ffa0c9cb27051b15dc9ea045f2023"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://baiyangzhang.github.io/blog/2024/Tsallis-Statistics-in-Logistic-Regression/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Baiyang Zhang</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Tsallis Statistics in Logistic Regression</h1> <p class="post-meta">May 20, 2024• Baiyang Zhang</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/tsallis"> <i class="fas fa-hashtag fa-sm"></i> tsallis</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <ul> <li> <a href="#1-introduction">1. Introduction</a> <ul> <li><a href="#11-the-basics-of-boltzmann-gibbs-extensive-entropy">1.1. The Basics of Boltzmann-Gibbs Extensive Entropy</a></li> <li><a href="#12-generalization-to-non-extensive-entropy">1.2. Generalization to non-Extensive entropy</a></li> </ul> </li> <li> <a href="#2-boltzmann-gibbs-statistical-mechanics">2. Boltzmann-Gibbs Statistical Mechanics</a> <ul> <li><a href="#21-three-different-forms-of-bg-entropy">2.1. Three different forms of BG entropy</a></li> <li><a href="#22-properties-of-bg-entropy">2.2. Properties of BG entropy</a></li> <li><a href="#23-constraints-and-entropy-optimization">2.3. Constraints and Entropy Optimization</a></li> </ul> </li> <li> <a href="#3-nonextensive-statistical-mechanics">3. Nonextensive Statistical Mechanics</a> <ul> <li><a href="#31-mean-value-in-tsallis-statistics">3.1. Mean Value in Tsallis Statistics</a></li> </ul> </li> <li> <a href="#4-tsallis-in-logistic-regression-methods">4. Tsallis in Logistic Regression Methods</a> <ul> <li><a href="#41-traditional-logistic-regression-method">4.1 Traditional logistic regression method</a></li> <li><a href="#with-tsallis-statistics">With Tsallis statistics</a></li> </ul> </li> <li><a href="#appendix-useful-mathematical-formulae">Appendix. Useful Mathematical Formulae</a></li> </ul> <h1 id="1-introduction">1. Introduction</h1> <p><code class="language-plaintext highlighter-rouge">Tsallis statistics</code> is a generalization of traditional statistical mechanics, devised by <em>Constantino Tsallis</em>, to better characterize complex systems. It involves a collection of mathematical functions and associated probability distributions that can be derived by optimizing the <code class="language-plaintext highlighter-rouge">Tsallis entropic form</code>, a generalization of familiar Boltzmann entropy. A key aspect of Tsallis statistics is the introduction of a real parameter $q$, which adjusts the distributions to exhibit properties intermediate between Gaussian and Levy distributions, reflecting the degree of non-extensivity of the system.</p> <p>Tsallis distributions include various families like the $q$-Gaussian, $q$-exponential, and $q$-Weibull distributions. These distributions are notable for their heavy tails and have been applied across diverse fields such as statistical mechanics, geology, astronomy, economics, and machine learning, among others.</p> <p>The adaptation of Tsallis statistics to these varied fields underscores its versatility in dealing with systems where traditional Boltzmann-Gibbs statistics might not be adequate, particularly in scenarios involving long-range interactions, memory effects, or multifractal structures. Tsallis statistics is particularly useful in the analysis of non-extensive systems, to <code class="language-plaintext highlighter-rouge">biostatistics</code> could offer a novel perspective on analyzing complex biological data. Tsallis statistics has been successfully applied in various complex physical systems, such as space plasmas, atmospheric dynamics, and seismogenesis, as well as in the analysis of brain and cardiac activity, showing excellent agreement between theoretical predictions and experimental data. This demonstrates the versatility and potential of Tsallis statistics in capturing the dynamics of complex systems, which could be beneficial in biostatistical applications.</p> <p>Given the interdisciplinary nature of biostatistics, which often deals with complex, high-dimensional data, the non-extensive framework of Tsallis statistics might offer new methodologies for data analysis. For instance, it could be useful in understanding the dynamics of ecosystems, population genetics, or the spread of diseases, where traditional models might not fully capture the underlying processes due to their complexity and the presence of long-range interactions.</p> <p>To explore this possibility further, one could start by investigating specific biostatistical problems where the assumptions of traditional statistical mechanics are not met, and then applying Tsallis statistics to see if it offers better predictive power or insights. It would also be beneficial to collaborate with experts in biostatistics to identify the most pressing challenges where Tsallis statistics could be applied.</p> <p>While the application of Tsallis statistics to biostatistics is an intriguing prospect, it is an emerging area that would require substantial interdisciplinary research to fully understand its potential and limitations. Below is a list of potential applications, take it with a grain of salt.</p> <ol> <li> <p><strong>Epidemiological Modeling</strong>: Tsallis statistics could be used to model the spread of diseases, especially in cases where traditional models fail to capture the long-range correlations between individuals in a population.</p> </li> <li> <p><strong>Genetic Data Analysis</strong>: Analysis of genetic sequences and variations, where non-extensive entropy might better capture the complexity and long-range dependencies within genetic information.</p> </li> <li> <p><strong>Protein Folding Dynamics</strong>: Investigating the non-linear dynamics of protein folding, where Tsallis statistics may offer insights into the anomalous diffusion processes involved.</p> </li> <li> <p><strong>Neural Network Analysis</strong>: Modeling the complex interactions within neural networks, particularly in understanding the non-linear dynamics of brain activities and signal transmissions.</p> </li> <li> <p><strong>Ecological Systems</strong>: Applying Tsallis statistics to model the complexity of ecological systems, where interactions can span vast spatial and temporal scales.</p> </li> <li> <p><strong>Cancer Growth Modeling</strong>: Understanding the anomalous growth patterns of tumors, where traditional models might not accurately capture the underlying dynamics.</p> </li> <li> <p><strong>Drug Response Modeling</strong>: Analyzing the variability in drug responses among populations, which may exhibit non-standard distribution patterns that Tsallis statistics could elucidate.</p> </li> <li> <p><strong>Heart Rate Variability Analysis</strong>: Investigating the complex, non-linear dynamics of heart rate variability, potentially uncovering new insights into cardiovascular health.</p> </li> <li> <p><strong>Analysis of Medical Imaging Data</strong>: Enhancing the interpretation of complex patterns in medical imaging, such as MRI or CT scans, through non-extensive statistical models.</p> </li> <li> <p><strong>Public Health Data Analysis</strong>: Applying Tsallis statistics to public health data, potentially uncovering new patterns or correlations in large-scale health trends.</p> </li> </ol> <hr> <h2 id="11-the-basics-of-boltzmann-gibbs-extensive-entropy">1.1. The Basics of Boltzmann-Gibbs Extensive Entropy</h2> <p><em>The whole theory of Tsallis statistics is based on a single concept: the modified Boltzmann-Gibbs (B-G) entropy</em> $S_ {q}$. $q$ is some index show how much $S_ {q}$ differs from the $BG$ entropy, if $q=1$ then there is no difference.</p> <p>To explain why the Boltzmann-Gibbs entropy is said to be additive, let’s first clarify what we mean by entropy in this context. In statistical mechanics, the Boltzmann-Gibbs entropy is a measure of the number of microstates that correspond to a given macrostate, providing a quantification of the system’s disorder or randomness.</p> <p>The formula for Boltzmann-Gibbs entropy, $S$, for a system in a particular <strong>macrostate</strong> is given by:</p> \[S = -k_B \sum_i p_i \ln p_i\] <p>where $p_i$ is the probability of the system being in the $i$-th microstate, and $k_B$ is the Boltzmann constant.</p> <p>Entropy is said to be additive when, for two independent systems $A$ and $B$, the total entropy $S_{AB}$ of the combined system is the sum of their individual entropies:</p> \[S_{AB} = S_A + S_B\] <p>This additivity property stems from the assumption of statistical independence of the two systems, which implies that the probability of the combined system $AB$ being in a particular microstate is the product of the probabilities of $A$ and $B$ being in their respective microstates. If $A$ is in a microstate with probability $p_i$ and $B$ is in a microstate with probability $q_j$, then the probability of the combined system being in the microstate characterized by both $p_i$ and $q_j$ is $p_i \cdot q_j$.</p> <p>As an example, consider two independent systems $A$ and $B$, each with two possible microstates. For system $A$, let the probabilities of the microstates be $p_1$ and $p_2$, and for system $B$, let them be $q_1$ and $q_2$. The entropies of systems $A$ and $B$ are:</p> <p>\(S_A = -k_B (p_1 \ln p_1 + p_2 \ln p_2)\) \(S_B = -k_B (q_1 \ln q_1 + q_2 \ln q_2)\)</p> <p>For the combined system $AB$, there are four possible microstates, with probabilities $p_1q_1, p_1q_2, p_2q_1,$ and $p_2q_2$. The entropy of the combined system is:</p> \[S _{AB} = -k_B [(p_1q_1) \ln (p_1q_1) + (p_1q_2) \ln (p_1q_2) + (p_2q_1) \ln (p_2q_1) + (p_2q_2) \ln (p_2q_2)]\] <p>With some algebra, you can show that:</p> \[S_{AB} = S_A + S_B .\] <p>This demonstrates the additivity of entropy for independent systems. <em>The crucial point here is the assumption of independence</em>, which allows the probabilities of the combined system to be expressed as products of the individual systems’ probabilities, leading directly to the additivity of entropy.</p> <p>Tsallis in his book compared his generalization of B-G statistics to $q$-statistics to the generalization of a circle to ellipses in explaining the motion of celestial objects. In both cases a single parameter changes everything. However I would argue that in the case of Kepler and others, more physics was revealed then in Tsallis’ case.</p> <h2 id="12-generalization-to-non-extensive-entropy">1.2. Generalization to non-Extensive entropy</h2> <p>In his book Tsallis listed some reasons for considering non-extensive, non-Boltzmann-Gibbs entropy, which can be roughly translated into:</p> <ol> <li>There is no (mathematical or physical) reason not to.</li> <li>A statistical description of a system should be based on the dynamics of the system, the macroscopic theory should come from a microscopic one. This opens the way, especially for complex systems, for other than Boltzmann statistics.</li> <li>The existence of long-range interactions on the microscopic level.</li> </ol> <h1 id="2-boltzmann-gibbs-statistical-mechanics">2. Boltzmann-Gibbs Statistical Mechanics</h1> <h2 id="21-three-different-forms-of-bg-entropy">2.1. Three different forms of BG entropy</h2> <p>No we need to come back to one of the most important concept in physics, statistics and information theory: <strong>entropy</strong>. It appears in various fields, each with its unique perspective but underlying similarities in concept.</p> <p>Generally, <em>entropy represents a measure of disorder, randomness, or uncertainty</em>. In statistics, entropy is a measure of the <strong>unpredictability</strong> or the <strong>randomness</strong> of a distribution. <em>The higher the entropy, the more unpredictable the outcome</em>. For example, in a perfectly uniform distribution where all outcomes are equally likely, entropy is at its maximum, indicating maximum uncertainty or disorder. In contrast, a distribution where one outcome is certain has zero entropy, representing complete order. This concept is used in various statistical methods and models to quantify uncertainty or variability within a dataset. In information theory, entropy is a fundamental concept introduced by <code class="language-plaintext highlighter-rouge">Claude Shannon</code>. It quantifies the average amount of information produced by a stochastic source of data. The more uncertain or random the source, the higher the entropy. In practical terms, entropy helps in understanding the limits of data compression and the efficiency of communication systems. For instance, a message composed of completely random bits has higher entropy and cannot be compressed beyond a certain limit without losing information. On the other hand, a message with a lot of repetitive or predictable parts has lower entropy and can be compressed more effectively.</p> <p>In each of these fields, entropy helps us understand systems’ behavior in terms of unpredictability, disorder, and efficiency. While the context and applications may vary, the core idea revolves around the concepts of uncertainty and the distribution of states or outcomes.</p> <p>In the previous section we showed the definition of entropy without much justification, because there is none! Not from the first principal at least. The programme to derive the expression of entropy that we are using today is sometimes called the Boltzmann program, since that was what Boltzmann was trying to do, before he strangled himself to death using a curtain or something.</p> <p>However, if the possibilities is a continuous distribution, the BG entropy must be modified accordingly, discrete probability $p_ {i}$ must be replaced by probability density $p(x)$ where $x$ is the variable. As a naively guess, I would say that we can write the entropy as</p> \[-k \sum p _ {i} \ln p _ {i} \to -k \int dx \, p(x) \ln(p(x)),\] <p>where the probability distribution function (or probability density) is normalized,</p> \[\int dx \, p(x) =1.\] <p>However, a difference between discrete and continuous probability lies in its dimension! Normalized discrete probabilities $p_ {i}$ sums to 1, $\sum_ {i} p_ {i}=1$, since $1$ is dimensionless, so is $p_ {i}$. This is not true for continuous probability density $p(x)$, since now the normalization condition tells us that $\int dx \, p(x)$ should be dimensionless, and $dx$ has the dimension of length, so $p(x)$ must have dimension of length inversed! Thus, wo need to introduce another parameter, call it $\sigma$, with dimension of length. Then we can define the BG entropy in the continuous scenario:</p> \[S_ {BG} = -k\int dx \, p(x) \ln(\sigma\, p(x)).\] <p>For the case of equal probabilities, that is, $p= 1 / \Omega$ where $\Omega$ is the total number of allowed microscopic states, we have</p> \[S_ {BG} = k \ln\left( \frac{\Omega}{\sigma} \right).\] <p>We just mention on the fly that, in quantum mechanics, the probabilistic distribution of a mixed state in terms of pure states is described using the density matrix $\rho$, and the BG entropy is generalized to</p> \[S_ {BF} = -k\,\mathrm{Tr}\, (\rho \ln \rho).\] <h2 id="22-properties-of-bg-entropy">2.2. Properties of BG entropy</h2> <p>We will list without proof some of the key properties of BG entropy.</p> <ul> <li> <strong>Non-negativity</strong>. $S\geq 0$ always. $S = k\ln \Omega$ might help to convince you of it.</li> <li> <strong>BG entropy is maximized at equal probability</strong>. Anything that drives the system away from it will decrease the entropy.</li> <li> <strong>Expansibility</strong>. Adding to a system new possible states with zero probability should not modify the entropy.</li> <li> <strong>Additivity</strong>. Let $A,B$ be two systems with entropy $S(A)$ and $S(B)$, putting them together will result in a new system $A+B$ with entropy $S(A+B)=S(A)+S(B)$.</li> <li> <strong>Concavity</strong>. Given two different probability distributions $\left\lbrace p_ {i} \right\rbrace$ and $\left\lbrace p’_ {i} \right\rbrace$, we can define an intermediate probability distribution</li> </ul> \[\widetilde{p}:= \lambda p + (1-\lambda)p',\quad \lambda \in (0,1).\] <p>Then we have</p> \[S(\widetilde{p})\equiv S(\lambda)&gt; \lambda S(p)+(1-\lambda)S(p').\] <p><strong>Shannon Uniqueness Theorem</strong>.</p> <p>In his work, Shannon was interested in finding a measure that could quantitatively capture the information content of a message source. He proposed several properties that this measure (which we now call entropy) should satisfy to be a useful and consistent measure of information. These properties included:</p> <ol> <li> <strong>Additivity</strong>: The entropy of two independent sources should be the sum of their individual entropies.</li> <li> <strong>Continuity</strong>: The measure should change continuously as the message probabilities change.</li> <li> <strong>Symmetry</strong>: The measure should not depend on the order of the messages.</li> <li> <strong>Maximum</strong>: The measure should be maximal for a uniform distribution, where all messages are equally likely.</li> </ol> <p>Shannon’s Uniqueness Theorem essentially states that, given these properties (along with a few others), the entropy of a discrete random variable is unique and is given by the now-familiar formula:</p> \[S = -\sum_{i} p(x_i) \ln p(x_i)\] <p>The theorem’s significance lies in its establishment of entropy as a <strong>unique measure</strong> that satisfies these intuitive and necessary properties for quantifying information. It solidified the concept of entropy as the foundational metric in information theory, leading to profound implications for communication, coding theory, and even other disciplines like statistics and thermodynamics.</p> <h2 id="23-constraints-and-entropy-optimization">2.3. Constraints and Entropy Optimization</h2> <p><strong>Imposing the Mean Value</strong></p> <p>We might know a priori the mean value of a variable $x$, i.e.</p> \[\left\langle x \right\rangle := \int dx \, x \, p(x) = \overline{x} \quad \text{ is known.}\] <p>We can apply the Lagrange multiplier method to find the optimizing distribution with the constraint, together with the normalization condition $\int dx \, p(x)=1$. The Lagrangian functional that we want to extremize reads now</p> \[\Phi[p(x)] = S_ {BG} - \alpha \int dx \, p(x) - \beta \int dx \, x \, p(x)\] <p>where we have neglected some constant terms since they don’t appear in the Euler-Lagrange equation, that is to say, they don’t affect the final result; and</p> \[S_ {BG} = -\int dx \, p(x)\ln p(x).\] <p>Using the method of variation, we get</p> \[p(x) = \frac{1}{\overline{x}} e^{ -x / \overline{x} }.\] <p><strong>Imposing the Mean value and the Mean Squared Value</strong></p> <p>Supposed that we not only know the mean value $\overline{x}=\left\langle x \right\rangle$, but also the mean square value $\left\langle x^{2} \right\rangle$:</p> \[\left\langle x^{2} \right\rangle \equiv \int dx \, (x-\left\langle x \right\rangle )^{2} p(x)\] <p>This time the Lagrangian reads</p> \[\Phi[p(x)] = S_ {BG} - \alpha \int dx \, p(x) - \beta_ {1}\int dx \, xp(x) - \beta_ {2} \int dx \, (x-\left\langle x \right\rangle )^{2}p(x).\] <p>Exactly as before, the variational method gives us</p> \[p(x) = \sqrt{ \frac{\beta_ {2}}{\pi} } \exp \left\lbrace -\beta_ {2}(x-\left\langle x \right\rangle )^{2} \right\rbrace\] <p>which is just the Gaussian distribution! This tells us that the Gaussian distribution maximizes the entropy with fixed mean and variance.</p> <h1 id="3-nonextensive-statistical-mechanics">3. Nonextensive Statistical Mechanics</h1> <p>Tsallis is convinced that there exists no logical-deductive procedure for generalizing any physical theory. As a possible motivation to generalize the exponential function $e^{ x }$, he started from the equation that $e^{ x }$ satisfies, which is fairly simple:</p> \[\frac{dy}{dx} = y.\] <p>A possible generalization of the equation is to writhe the RHS as $a+by$, we have</p> \[\frac{dy}{dx} = a+by \implies \frac{dy}{a+by}=dx\implies y=\frac{1}{b}(e^{ b(x+c) }-a),\] <p>which does look very promising. Then Tsallis considered a non-linear generalization:</p> \[\frac{dy}{dx} = y^{q}, \quad q\in \mathbb{R},\quad y(0)=1.\] <p>The boundary condition $y(0)=1$ is such that is agrees with the usual exponential function $e^{ 0 }=1$. Solving it we get</p> <p>\((1-q) (x+c) = y^{1-q} ,\) the boundary condition translates to</p> \[c = \frac{1}{1-q},\] <p>thus</p> \[\boxed{ y = (1+(1-q)x)^{1/(1-q)} =: e_ {q}^{x}. }\] <p>When $1+(1-q)x&lt;0$, $e_ {q}(x)$ is defined to be zero (<strong>why don’t complexify it</strong>?). Also note that $e^{ x }_ {q}$ goes to $e^{ x }$ at $q\to 1$ since, writing $q = 1-\epsilon$, we have</p> \[\lim_ { q \to 1 } e^{ x }_ {q} = \lim_ { \epsilon \to 0 } (1+\epsilon x)^{1/\epsilon} = e^{ x }.\] <p>From the same equation that we got the definition of $e^{ x }_ {q}$, we also get the inverse function of $x$ in terms of $y$:</p> \[\boxed{ x = \frac{y^{1-q}-1}{1-q} =: \log_ {q} y. }\] <p>They are referred to as $q$-exponential functions and $q$-logarithmic functions respectively.</p> <p>Recall that logarithmic functions turns multiplication into addition, $\log(AB)=\log(A)+\log(B)$, for $q$-logarithmic functions we have something similar,</p> \[\log_ {q}(AB) = \log_ {q}(A) + \log_ {q}(B) + (1-q) \log_ {q}(A)\log_ {q}(A).\] <h2 id="31-mean-value-in-tsallis-statistics">3.1. Mean Value in Tsallis Statistics</h2> <p>There are three types of Tsallis statistics, depending on how they take the mean value. Next we will discuss each of them in chronological order.</p> <p>Throughout the note we will assume that probabilities are normalized in the usual way,</p> \[\sum_ {i} p_ {i} = 1.\] <p>Given an observable $\mathcal{O}$, what could be the expected value $\left\langle \mathcal{O} \right\rangle$? The most naive guess, which is also the default definition, is to define</p> \[\left\langle \mathcal{O} \right\rangle := \sum_ {i} p _ {i} O_ {i}\] <p>where $\mathcal{O}_ {i}$ is the $i$-th possible value of $\mathcal{O}$ with probability $p_ {i}$. However, this definition yields and ill-defined thermodynamic distribution, <em>some energy states will not be allowed due to mathematical rather than physical reasons, and the distribution is not invariant under an overall shift in energy</em>. Normally only the energy difference matter, the only situation that I know of where the absolute energy matters is from gravity, which is clearly not the case here. Thus it is not a good definition for taking average.</p> <hr> <p>Another way to define the average, known as Tsallis type II, is</p> <p>\(\left\langle \mathcal{O} \right\rangle := \sum_ {i} p_ {i}^{q} \mathcal{O}_ i.\) The problem is similar with type I, the sample space is constraint due to some un-natural reason, which I tend to interpret as the evidence of an ill-defined theory. Some divergence that occurs in type I does not occur here, but it introduces new problems, most of all the expected value of unity $\mathbb{1}$ is not $1$.</p> <p>However there is a remedy. Arguing from the point of view of information theory on incomplete probability distributions, Q. A. Wang suggested modifying the normalization of probability as</p> \[\sum_ {i} p_ {i}^{q} = 1.\] <p>This can be rewritten by defining $P_ {i}:= p_ {i}^{1}$, then</p> \[\left\langle \mathcal{O} \right\rangle := \sum_ {i} P_ {i} \mathcal{O}_ {i} .\] <hr> <p>Type III assumes that the average is defined as type II but with an normalization factor:</p> \[\left\langle \mathcal{O} \right\rangle := N \sum_ {i} p_ {i}^{q}\mathcal{O}_ {i},\quad N = \sum_ {i}p_ {i}.\] <p>This solves the problem that the expectation value of identity $1$ is not $1$. The probability derived from is also becomes invariant under an overall shift.</p> <h1 id="4-tsallis-in-logistic-regression-methods">4. Tsallis in Logistic Regression Methods</h1> <p>This part will be presented in a much less pedagogical way, we will simply introduce new functions and concepts along the way.</p> <p>Before I could apply Tsallis statistics to medical data, I need first to figure out how the traditional method works.</p> <h2 id="41-traditional-logistic-regression-method">4.1 Traditional logistic regression method</h2> <p>Consider a matrix $X_ {n \times p}$ representing the expression of $p$ genes from $n$ samples, obtained through technologies like microarray or RNA-seq. Here, $p \gg n$, which leads to the well-known <em>big $p$, small $n$</em> problem. The response, or dependent variables (observables), is denoted by an $n$-vector $\vec{y} = (y_ 1, \cdots, y_ n)$. Each $y_ i$ is a binary variable, taking values 0 or 1. For example, in a clinical context, think of each sample as a patient; $y_ i = 1$ might indicate that patient $i$ is cured of, or has, a certain disease, while $y_ i = 0$ indicates the opposite. Currently, we are focusing on a mathematical model, so the exact biological or clinical significance of $y = 1$ is not specified. The values of $\vec{y}$ follow a Bernoulli distribution, which will be discussed in more detail shortly.</p> <p>We can organize all the gene expressions from all the samples into a single matrix $X$,</p> \[X = \begin{pmatrix} x_ {11} &amp; \cdots &amp; x_ {1p} \\ x_ {21} &amp; \cdots &amp; x_ {2p} \\ \vdots &amp; \ddots &amp; \vdots \\ x_ {n1} &amp; \cdots &amp; x_ {np} \end{pmatrix}.\] <p>In the above matrix, each row is a vector of different genes from one sample, while each column is vector of different patients with one type of gene. We use $X_ {i}$ to denote the expression of the $i$-th gene across $n$ samples, which corresponds to the $i$-th column of $X$. Conversely, $X^{T}_ {(j)}$ represents the genes expression observed in $j$-th sample (one patient $j$), namely the $j$-th row. The transpose is such that $X_ {(j)}$ is a column vector, just like $X_ {a}$. Be aware that the distinction in notation is merely the addition of parentheses. In general, $X$ is our data and $\vec{y}$ will be the dependent variable. In practice, it is known which patients are treated and which are not, hence we know the observed value of $\vec{y}$. The problem is to find a way to <strong>predict</strong> $y_ {a}$ from an observed vector of genes expressions $X_ {(a)}$. But first, we need to know the role played by each gene expressed in different patients, that is, we need to know how to interpret $X_ {a}$ for gene $a$. For example, if $X_ {a}$ is a constant vector for all the patients, then we know that gene $a$ most likely has nothing to do with the disease of study.</p> <hr> <p>Let us now delve into the mathematical foundations of the model.</p> <p>Let $\pi_ {i}$ be the probability of $y_ {i}=1$, which we aim to predict. Following the standard logistic regression method, we define the logit (log here is used as a verb, <strong>log</strong>-it) function of $\pi_ {i}$,</p> \[\text{logit}(\pi_ {i} ) := \ln\left( \frac{\pi_ {i}}{1-\pi_ {i}} \right), \quad \text{logit}: [0,1]\to \mathbb{R}.\] <p>$\pi$ is the probability, and $\pi / (1-\pi)$ is called <code class="language-plaintext highlighter-rouge">odd</code> with range $\mathbb{R}^{+}:=[0,\infty)$. Note that in our convention zero is included in $\mathbb{R}^{+}$.</p> <p>Since we have constructed a continuous function $\text{logit}(\pi)$ from a probability function $\pi$, we can now adopt familiar <em>linear regression method</em> and apply it to the logit function. Parametrize the logit function in a linear form</p> \[\text{logit}(\pi_ {i}) := \beta_ {0}+X_ {(i)}\cdot\beta, \quad \beta=(\beta_ {1},\cdots,\beta_ {p}).\] <p>$\beta$ is the parameter vector to be fixed later. Note the dot product is the product between vectors, $X \cdot \beta:= X^{T} \beta$ .</p> <p>Direct derivation shows that</p> \[\pi_ {i} = \frac{1}{1+\exp(-\beta_ {0}-X_ {(i)}\cdot \beta)}=:\text{sigm}(\beta_ {0}+X_ {(i)}\cdot \beta),\] <p>where $\text{sigm}$ stands for sigmoid function, which literally means a function that has an $S$-shape. In our particular case the sigmoid function is give by</p> \[\text{sigm}(t) := \frac{1}{1+e^{ -t }}.\] <p>Note that $\text{sigm}$ is the inverse of $\text{logit}$,</p> \[\text{logit}(\pi)=x \Longleftrightarrow \pi = \text{logit}^{-1}(x) = \text{sigm}(x).\] <p>I am not sure if there exists other widely-applied definitions for sigmoid function except for that given above. There surely are other functions with an S-shape, such as tanh and arctan, but I am not sure if they can be called sigmoids? Or maybe difference in the predictive power by introducing different choices of sigmoid functions are negligible, hence it only makes sense that we stuck with the simplest option?</p> <p>Now, the question is how can we fix the parameters? The natural answer is: by maximizing the likelihood, or equivalent by minimizing the loss function. The likelihood function, by definition, is the probability (likelihood) for a certain observation $\vec{y}$. This function measures the probability of observing the given data under certain model, with parameters being estimated. For instance, supposed there are three samples (binary), then the likelihood of $y=(1,0,1)$ corresponds to the probability predicted by our model that the first and third patients have got some disease, while the second does not. Now, the probability for each $y_ {i}=1$ is $\pi_ {i}$, which is by definition $\text{sigm}(t_ {i})\equiv1/(1-e^{ -t_ {i} })$, where $t=\beta_ {0}+X_ {(i)}\cdot \beta$, and $\beta$’s are the parameters. The probability for $y_ {i}=0$ is $1- 1/(1-e^{ -ti })$, which is $e^{ -t_ {i} }/(1-e^{ -t_ {i} })$. Then, the likelihood for observing $y=(1,0,1)$ is simply the product of each probability,</p> \[\text{lik}(1,0,1) = \frac{1}{1-e^{ -t_ {1} }} \frac{e^{ -t_ {2} }}{1-e^{ -t_ {2} }} \frac{1}{1-e^{ -t_ {3} }},\] <p>which is a function of parameters $\beta$’s and observed gene expression $X_ {(i)}$.</p> <p>Likelihood function can also be written using the <code class="language-plaintext highlighter-rouge">Bernoulli distribution</code> function, which is a probability distribution function (PDF) that has only two possible outcomes, 1 and 0, with probability $\pi$ for $y=1$ and $1-\pi$ for $y=0$. This distribution is a special case of the binomial distribution where the number of trials $n$ is equal to 1. The <strong>Probability Mass Function (PMF)</strong> of Bernoulli distribution is defined as</p> \[P(y) := \pi^y (1-\pi)^{1-y}, \quad y=0 \text{ or }1,\] <p>where $\pi$ is given <em>a priori</em>. The Expected Value is $\left\langle y \right\rangle=\pi$ and the variance is $\text{Var}(y) = \pi(1-\pi)$, you can verify it easily. This neat expression unites both cases $y=0$ and $y=1$. Applying it to the likelihood function we get</p> \[\text{lik}(1,0,1) = \prod_ {i=1}^{3} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}}, \quad \vec{y}=(1,0,1).\] <p>Generalization to arbitrary $\vec{y}$ is trivial,</p> \[\text{lik}(\vec{y}) := \prod_ {i=1}^{n} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}}, \quad \vec{y}=(y_ {1},\cdots,y_ {n}).\] <p>The above expression can be further simplified using logarithms. Recall that logarithm is a <em>monotonically increasing</em> function, it means that $\log(\text{lik}(\vec{y}))$ is maximized iff (if and only if) $\text{lik}(\vec{y})$ is maximized. The reason why it is a good idea to take the logarithm of the likelihood is the following.</p> <ol> <li> <p><strong>Numerical Stability</strong>: The likelihood function in models like logistic regression involves products of probabilities, which can be very small numbers. When multiplying many such small probabilities, the result can become extremely small, potentially leading to numerical underflow (where values are so small that the computer treats them as zero). The logarithm of these small numbers turns them into more manageable, larger negative numbers, reducing the risk of numerical issues.</p> </li> <li> <p><strong>Simplification of Products into Sums</strong>: The likelihood function involves taking the product of probability values across all data points. In contrast, the log-likelihood converts these products into sums by the property of logarithms $\ln(ab) = \ln(a) + \ln(b)$. Sums are much easier to handle analytically and computationally. This is especially useful when dealing with large datasets.</p> </li> <li> <p><strong>Convexity Properties</strong>: The log-likelihood function often yields a convex optimization problem in cases where the likelihood itself is not convex. Convex problems are generally easier to solve reliably and efficiently. For logistic regression, the log-likelihood function is concave, and finding its maximum is a well-behaved optimization problem with nice theoretical properties regarding convergence and uniqueness of the solution.</p> </li> <li> <p><strong>Derivative Computation</strong>: The derivatives of the log-likelihood (needed for optimization algorithms like gradient ascent or Newton-Raphson) are typically simpler to compute and work with than the derivatives of the likelihood function. This simplicity arises because the derivative of a sum (log-likelihood) is more straightforward than the derivative of a product (likelihood).</p> </li> </ol> <p>Last but not least,</p> <ol> <li> <strong>Possibility to introduce the Tsallis statistics</strong>: We have explain how the Tsallis statistics modified traditional exponential and logarithmic functions, <em>in our case the log-likelihood function can be generalized by adopting the Tsallis logarithm, namely $\log_ {q}$.</em> In the next section we will try to explain the advantage of such generalization, which will also serve as justification. But of course, being a phenomenological model, the true justification will be the power of prediction, which can only be tested in real-life practice.</li> </ol> <p>But for now, let’s forget about Tsallis and carry on on the road of conventional logic regression method.</p> <p>Taking the natural log of likelihood function gets us</p> \[\begin{align*} \text{loglik}(\vec{y}) &amp;:=\log(\text{lik}(\vec{y}))= \ln \left\lbrace \prod_ {i=1}^{n} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}} \right\rbrace \\ &amp;=\sum_ {i} \left\lbrace y_ {i} \ln\pi_ {i}+(1-y_ {i}) \ln(1-\pi_ {i}) \right\rbrace. \end{align*}\] <p>In the context of logistic regression, people often use the loss function, defined as the negative of the likelihood function. This is primarily due to convention and practical considerations in optimization processes, since most optimization algorithms and tools are designed to minimize functions rather than maximize them. This is a common convention in mathematical optimization and numerical methods. Since maximizing the likelihood is equivalent to minimizing the negative of the likelihood, formulating the problem as a minimization problem allows us the application of standard, widely available optimization software and algorithms without modification. In many statistical learning methods, the objective function is often interpreted as a “cost” or “loss” that needs to be minimized. When working with a loss function, the goal is to find parameter estimates that result in the smallest possible loss. Defining the loss function as the negative log-likelihood aligns with this interpretation because lower values of the loss function correspond to higher likelihoods of the data under the model.</p> <p>Furthermore, using a loss function that is to be minimized creates a consistent framework across various statistical learning methods, many of which inherently involve minimization (like least squares for linear regression, and more complex regularization methods in machine learning). This consistency is helpful not only from an educational and conceptual standpoint but also from a practical implementation standpoint.</p> <p>A <code class="language-plaintext highlighter-rouge">regularized loss function</code> is the loss function with <code class="language-plaintext highlighter-rouge">penalty terms</code>. Penalty terms in regression methods are essential for managing several challenges that arise in statistical modeling, particularly with high-dimensional data. These challenges include <em>overfitting</em>, <em>multicollinearity</em>, and <em>interpretability</em>.</p> <p>One of the primary reasons for using penalty terms is to prevent overfitting. Overfitting occurs when a model captures not just the true underlying pattern but also the random fluctuations (noise) in the data. This makes the model very accurate on the training data but <em>poorly generalized to new, unseen data</em>. By adding a penalty term, which increases as the model complexity increases (e.g., as coefficients become larger), the optimization process is biased towards simpler models. This helps to ensure that the model generalizes well to new data by focusing on the most significant predictors and shrinking the others.</p> <p>Multicollinearity occurs when two or more predictor variables in a regression model are highly correlated. This can make the model estimation unstable and the estimates of the coefficients unreliable and highly sensitive to small changes in the model or the data. Penalty terms, especially those like Lasso regression (L1 penalty) or Ridge regression (L2 penalty), can reduce the impact of multicollinearity by penalizing the size of the coefficients, thus stabilizing the estimates. In high-dimensional datasets where the number of predictors $p$ exceeds the number of observations $n$ or when there are many irrelevant features, selecting the most relevant features becomes crucial. Lasso regression (L1 penalty) is particularly useful for this purpose because it can shrink some coefficients to exactly zero, effectively performing variable selection. This helps in identifying which predictors are most important for the outcome, simplifying the model and improving interpretability.</p> <p>By shrinking coefficients or reducing the number of variables, penalty terms help in simplifying the model. A simpler model with fewer variables or smaller coefficients is easier to understand and interpret. This is particularly valuable in domains like medical science or policy-making, where understanding the influence of predictors is as important as the prediction itself.</p> <p>However it is also important to realize the disadvantages of introducing penalty terms, that is the bias-variance tradeoff. Adding a penalty term introduces bias into the estimator for the coefficients (the estimates are “shrunk” towards zero or towards each other in the case of Ridge). However, this can lead to a significant reduction in variance (the estimates are less sensitive to fluctuations in the data). This trade-off can lead to better predictive performance on new data, which is the ultimate goal of most predictive modeling tasks.</p> <hr> <p>In our project, we consider the regularized loss function as following.</p> \[l(\beta_ {0}, \vec{\beta}) := -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\pi_ {i})+(1-y_ {i})\ln(1-\pi_ {i}) \right\rbrace +h(\vec{\beta}),\] <p>where $h(\vec{\beta})$ is the penalty terms and is independent of $\beta_ {0}$, which is simply a shift. $h(\vec{\beta})$ could be the Lasso (<code class="language-plaintext highlighter-rouge">Least Absolute Shrinkage and Selection Operator</code>) term, or ridge term.</p> <hr> <p>We now introduce the <strong>Group Lasso regression</strong> method. Group Lasso regression is an extension of Lasso that is particularly useful in the context of biostatistics, especially when dealing with models that incorporate multiple predictors which naturally group into clusters. This method not only encourages sparsity in the coefficients, like traditional Lasso, but also takes into account the structure of the data by promoting or penalizing entire groups of coefficients together. Here’s an introduction to how Group Lasso works and why it’s valuable in biostatistics:</p> <p>In many biostatistical applications, predictors can be inherently grouped based on biological function, measurement type, or other domain-specific knowledge. For example, genes might be grouped into pathways, or clinical measurements might be grouped by the type of instrument used or the biological system they measure.</p> <p>The key idea behind Group Lasso is to <em>perform regularization and variable selection at the group level</em>. The formulation of Group Lasso is similar to that of Lasso, but instead of summing the absolute values of coefficients, it sums the norms of the coefficients for each group. The objective function for Group Lasso can be written as:</p> \[\text{Minimize:} \quad \text{loss function} + h(\vec{\beta}), \quad h(\vec{\beta}):= \lambda \sum_ {g=1}^G w_ g \left\lVert \vec{\beta}_{(g)} \right\rVert_ {2}\] <p>where $\vec{\beta}$ represents the coefficient vector, $\vec{\beta}_ {(g)}$ is the sub-vector of coefficients corresponding to group $g$. Note the difference between $\beta_ {g}$ and $\beta_ {(g)}$, the former is a component of $\vec{\beta}$ thus a number, while the latter is a sub-vector of $\vec{\beta}$. $G$ is the total number of groups, $w_g$ are weights that can be used to scale the penalty for different groups, often based on group size or other criteria, $\left\lVert \vec{\beta}_ {(g)} \right\rVert$ is typically the Euclidean norm (L2 norm) of the coefficients in group $g$ or, as is shown in ShunJie’s paper, the PCC (Pearson correlation coefficient) distance, or shape-based distance. $\lambda$ is a <strong>global</strong> tuning parameter that controls the overall strength of the penalty.</p> <p>In our current project, we use square root of the degree of freedom (dof) as the weight for different groups. The penalty term is then</p> \[h(\beta) = \lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} } \left\lVert \vec{\beta}_ {g} \right\rVert _ {2} =: \lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} }\; r_ {g}\] <p>where $d_ {g}$ is the number of genes in group $g$, or dimension of $\vec{\beta}_ {g}$, $\vec{\beta}_ {g}$ is treated as a $d_ {g}$-vector of parameters, and $r_ {g}$ is the radius of $\vec{\beta}_ {g}$. Naturally it is a subset of $\beta$.</p> <p>Recall that $\sqrt{ d_ {g} }$ is the expected length of $d_ {g}$ i.i.d. variables, independent and identically distributed variables. The factor $\sqrt{d_ g}$ is to adjust for the size of each group, it scales up the penalty proportional to the group size. This means that larger groups, which naturally have a potentially larger norm due to more coefficients, receive a proportionally larger penalty. By multiplying the norm by $\sqrt{d_ g}$, the intention is to make the penalty fair by ensuring that the regularization is proportional to the number of parameters in the group. Without this scaling, smaller groups could be unfairly penalized in relative terms because their norms are naturally smaller due to fewer components. For example, consider two groups in a regression setting:</p> <ul> <li>Group 1: Contains 1 coefficient, $\mathbf{w}_ 1 = (3)$.</li> <li>Group 2: Contains 4 coefficients, $\mathbf{w}_ 2 = (1, 1, 1, 1)$.</li> </ul> <p>Without any normalization, we have</p> <ul> <li>The norm for Group 1 is $\left\lVert w_ {1} \right\rVert_ 2 = \left\lvert 3 \right\rvert = 3$.</li> <li>The norm for Group 2 is $\left\lVert w_ {2} \right\rVert_ 2 = \sqrt{1^2 + 1^2 + 1^2 + 1^2} = 2$.</li> </ul> <p>Here, the raw norms suggest that Group 1 might be more significant, which could distort the model’s view. Using $d_ g$ for normalization instead, we have:</p> <ul> <li>For Group 1: $1 \times \left\lvert 3 \right\rvert= 3$.</li> <li>For Group 2: $4 \times 2 = 8$.</li> </ul> <p>This overcorrects, making the penalty overly sensitive to the number of components, and could lead to under-penalizing smaller groups. Thus we decide to use $\sqrt{d_ g}$ for normalization:</p> <ul> <li>For Group 1: $\sqrt{1} \times 3 = 3$.</li> <li>For Group 2: $\sqrt{4} \times 2 = 2 \times 2 = 4$.</li> </ul> <p>This balances the penalties more reasonably, reflecting that while Group 2 is larger, its collective contribution should be seen in proportion to the natural growth of norms with group size, not exponentially with each addition.</p> <hr> <p>We recall that $X_ {(i)}$ is the expression of different genes from one patient $i$, in terms of $X_ {(i)}$ is given the probability:</p> \[\pi_ {i} = \frac{1}{1+\exp(-\beta_ {0}-X_ {(i)}\cdot \beta)}=\text{sigm}(\beta_ {0}+X_ {(i)}\cdot \beta)=\text{sigm}(t_ {i} ),\] <p>where the sigmoid function is give by</p> \[\text{sigm}(t_ {i} ) := \frac{1}{1+e^{ -t_ {i} }}, \quad t_ {i} := \beta_ {0}+X_ {(i)}\cdot \beta.\] <p>The loss function is given by the negative log-likelihood function plus the penalty term, including a punish term:</p> \[\begin{align*} l(\beta) &amp;= -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\pi_ {i})+(1-y_ {i})\ln(1-\pi_ {i}) \right\rbrace +h(\vec{\beta})\\ &amp;= -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\text{sigm}(t_ {i} ))+(1-y_ {i})\ln(\text{sigm}(-t_ {i} )) \right\rbrace +h(\vec{\beta})\\ &amp;= -\sum_ {i} \left\lbrace y_ {i}\ln\left( \frac{\text{sigm}(t_ {i} )}{\text{sigm}(-t_ {i} )} \right) + \ln\, \text{sigm}(-t_ {i} ) \right\rbrace + h(\beta) \\ &amp;= -\sum_ {i}[y_ {i}t_ {i} -\ln(1+e^{ t_ {i} })] + h(\beta)\\ &amp;=: J(\beta)+h(\beta), \end{align*}\] <p>where in the first line we have exploit the fact that the sigmoid function is symmetric, and write $l(\vec{\beta})$ in terms of sigmoid function for future convenience. To be specific, in future work we will consider generalization for sigmoid function with Tsallis q-logarithms, so we might just write the loss functions explicitly in terms of it as well. $h(\beta)$ is the Lasso penalty term given by $\lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} } \left\lVert \vec{\beta}_ {g} \right\rVert _ {2}$. $J(\beta)$ is the minus likelihood function,</p> \[\boxed{ J(\beta):= -\sum_ {i}[y_ {i}t_ {i} -\ln(1+e^{ t_ {i} })],\quad t_ {i} =\beta_ {0}+\beta \cdot X_ {(i)}. } ,\] <hr> <p>As usual, the loss function is convex and non-linear. Since we took the absolute value of $\left\lVert \vec{\beta}_ {g} \right\rVert$, it is not smooth at $\vec{\beta}=0$. However it is not a big problem in minimization problem, since it is piece-wise smooth, we simply need to consider the behavior from both sides of the non-smooth point. In the case of a LASSO punish term, that is the origin or each $\vec{\beta}_ {g}$.</p> <p>For Group LASSO regression, the goal is to apply LASSO regularization to groups of coefficients rather than individual coefficients. This means entire groups of variables can be zeroed out together, which encourages group-wise sparsity in the model. The challenge with Group LASSO is the non-differentiability of the regularization term, similar to standard LASSO but applied to norms of groups of coefficients.</p> <p>Several methods can be used to solve the Group LASSO problem efficiently:</p> <ol> <li> <p>Coordinate Descent: This method can still be adapted for Group LASSO by modifying it to work on groups of coefficients rather than individual coefficients. In this context, the update step involves a group soft-thresholding operation, which is a generalization of the soft-thresholding used in standard LASSO.</p> </li> <li> <p><strong>Proximal Gradient Methods</strong>: These are particularly well-suited for Group LASSO due to their ability to handle non-smooth terms efficiently. The proximal operator for the Group LASSO regularization term can be defined explicitly, allowing for straightforward implementation. This method iteratively updates the coefficients by taking a gradient step on the differentiable loss function and then applying the proximal operator to handle the group sparsity.</p> </li> <li> <p><strong>Block Coordinate Descent</strong>: This is a variant of coordinate descent that updates blocks (or groups) of variables at once rather than individual variables. It is particularly useful in Group LASSO, where you want to consider the impact of an entire group of variables together when deciding on updates.</p> </li> <li> <p>Primal-Dual Methods: These methods work by simultaneously updating primal and dual variables to find a solution that satisfies the optimality conditions for both. They can be very efficient for problems like Group LASSO, where the structure of the groups can be exploited to simplify the dual problem.</p> </li> </ol> <p>Among these methods, <strong>Proximal Gradient Methods</strong> and <strong>Block Coordinate Descent</strong> are often the most effective for solving Group LASSO due to their ability to directly handle the group-wise structure and non-smoothness of the regularization term. The choice between these methods may depend on the specific structure of your problem and the size of your data.</p> <h2 id="42-with-tsallis-statistics">4.2 With Tsallis statistics</h2> <h1 id="appendix-useful-mathematical-formulae">Appendix. Useful Mathematical Formulae</h1> <p>The definition of $q$-logarithm and $q$-exponential, $x&gt;0, q \in\mathbb{R}$:</p> \[\begin{align*} \ln_ {q}x &amp;:= \frac{x^{1-q}-1}{1-q}, \\ e^{ x }_ {q} &amp;:= (1+(1-q)x)^{1/(1-q)}, \end{align*}\] <p>in the definition of the exponential it is required that $1+(1-q)x&gt;0$, otherwise it is defined to be zero. It is easily checked that they are indeed inverse to each other.</p> <p>many formula for $q$-logarithms reminds us of that for the regular $q$-logarithms.</p> \[\begin{align*} \ln_ {q}(xy) &amp;= \ln_ {q}(x)+ \ln_ {q}(y) + (1-q)\ln_ {q}(x)\ln_ {q}(x) , \\ \ln_ {q}(1+x) &amp;= \sum_ {1}^{\infty} (-1)^{n-1} \frac{(q)_ {n}}{n!} x^{n}, \\ (q)_ {n} &amp;= \frac{\Gamma(q+k)}{\Gamma(q)} = q(q+1)\cdots(q+k-1), \\ \ln_ {q}\prod_ {k=1}^{n}x_ {k} &amp;= \sum_ {k=1}^{n} (1-q)^{k-1}\sum_ {i_ {k} &gt;\cdots&gt;i_ {1}=1}^{n} \ln_ {q}x_ {i_ {1}}\cdots\ln_ {q}x_ {i_ {k}}. \end{align*}\] <p>We also have</p> \[\begin{align*} \ln_ {q} x &amp;= x^{1-q}\ln_ {2-q}x , \\ q \ln_ {1-q}x^{a} &amp;= a \ln_ {1-a} x^{q} . \end{align*}\] <p>Regarding the $q$-exponentials,</p> \[\begin{align*} \left( e_ {q}^{f(x)} \right) ^{a} &amp;= e^{ af(x) }_ {1-(1-q)/a},\\ \frac{d}{dx} e_ {q}^{f(x)} &amp;= (e_ {q}^{f(x)})^{q} \times f'(x) \end{align*}\] <p>For more details, refer to the textbook by Tsallis himself and <a href="https://doi.org/10.1016/S0378-4371(01)00567-2" title="Persistent link using digital object identifier" rel="external nofollow noopener" target="_blank">https://doi.org/10.1016/S0378-4371(01)00567-2</a>.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/displaying-external-posts-on-your-al-folio-blog/">Displaying External Posts on Your al-folio Blog</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Basic-Category-Theory-Lecture-3/">Basic Category Theory Lecture 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Classical-Lumps-and-Their-Quantum-Descendants/">Note on Classical Lumps and Their Quantum Descendants</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Note-on-The-Moral-Foundations-of-Politics/">Note on The Moral Foundations of Politics</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Perturbative-Spontaneous-Symmetry-Breaking/">Perturbative Spontaneous Symmetry Breaking</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Baiyang Zhang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: May 22, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams",inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}};</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>