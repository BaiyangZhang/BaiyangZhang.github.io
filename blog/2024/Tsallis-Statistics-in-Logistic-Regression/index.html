<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Tsallis Statistics in Logistic Regression | Baiyang Zhang</title> <meta name="author" content="Baiyang Zhang"> <meta name="description" content="A place dedicated to sharing insights and reflections on mathematics, physics, and social sciences. "> <meta name="keywords" content="mathematics, physics, academic-website, portfolio-website"> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],tags:"all",tagSide:"right",tagIndent:"0.8em",processEscapes:!0},startup:{ready:function(){console.log("MathJax is ready and configured for automatic equation numbering."),MathJax.startup.defaultReady()}}};</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/z.png?010ffa0c9cb27051b15dc9ea045f2023"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://baiyangzhang.github.io/blog/2024/Tsallis-Statistics-in-Logistic-Regression/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Baiyang Zhang</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Tsallis Statistics in Logistic Regression</h1> <p class="post-meta">October 16, 2024• Baiyang Zhang</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/tsallis"> <i class="fas fa-hashtag fa-sm"></i> tsallis</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <ul> <li> <a href="#1-introduction">1. Introduction</a> <ul> <li><a href="#11-the-basics-of-boltzmann-gibbs-extensive-entropy">1.1. The Basics of Boltzmann-Gibbs Extensive Entropy</a></li> <li><a href="#12-generalization-to-non-extensive-entropy">1.2. Generalization to non-Extensive entropy</a></li> </ul> </li> <li> <a href="#2-boltzmann-gibbs-statistical-mechanics">2. Boltzmann-Gibbs Statistical Mechanics</a> <ul> <li><a href="#21-three-different-forms-of-bg-entropy">2.1. Three different forms of BG entropy</a></li> <li><a href="#22-properties-of-bg-entropy">2.2. Properties of BG entropy</a></li> <li><a href="#23-constraints-and-entropy-optimization">2.3. Constraints and Entropy Optimization</a></li> </ul> </li> <li> <a href="#3-nonextensive-statistical-mechanics">3. Nonextensive Statistical Mechanics</a> <ul> <li><a href="#31-mean-value-in-tsallis-statistics">3.1. Mean Value in Tsallis Statistics</a></li> </ul> </li> <li> <a href="#4-tsallis-in-logistic-regression-methods">4. Tsallis in Logistic Regression Methods</a> <ul> <li><a href="#41-traditional-logistic-regression-method">4.1 Traditional logistic regression method</a></li> <li><a href="#42-with-tsallis-statistics">4.2 With Tsallis statistics</a></li> </ul> </li> <li><a href="#appendix-useful-mathematical-formulae">Appendix. Useful Mathematical Formulae</a></li> </ul> <h1 id="1-introduction">1. Introduction</h1> <p><code class="language-plaintext highlighter-rouge">Tsallis statistics</code> is a generalization of traditional statistical mechanics, devised by <em>Constantino Tsallis</em>, to better characterize complex systems. It involves a collection of mathematical functions and associated probability distributions that can be derived by optimizing the <code class="language-plaintext highlighter-rouge">Tsallis entropic form</code>, a generalization of familiar Boltzmann entropy. A key aspect of Tsallis statistics is the introduction of a real parameter $q$, which adjusts the distributions to exhibit properties intermediate between Gaussian and Levy distributions, reflecting the degree of nonextensivity of the system.</p> <p>Tsallis distributions include various families like the $q$-Gaussian, $q$-exponential, and $q$-Weibull distributions. These distributions are notable for their heavy tails and have been applied across diverse fields such as statistical mechanics, geology, astronomy, economics, and machine learning, among others.</p> <p>The adaptation of Tsallis statistics to these varied fields underscores its versatility in dealing with systems where traditional Boltzmann-Gibbs statistics might not be adequate, particularly in scenarios involving long-range interactions, memory effects, or multifractal structures. Tsallis statistics is particularly useful in the analysis of non-extensive systems, to <code class="language-plaintext highlighter-rouge">biostatistics</code> could offer a novel perspective on analyzing complex biological data. Tsallis statistics has been successfully applied in various complex physical systems, such as space plasmas, atmospheric dynamics, and seismogenesis, as well as in the analysis of brain and cardiac activity, showing excellent agreement between theoretical predictions and experimental data. This demonstrates the versatility and potential of Tsallis statistics in capturing the dynamics of complex systems, which could be beneficial in biostatistical applications.</p> <p>Given the interdisciplinary nature of biostatistics, which often deals with complex, high-dimensional data, the non-extensive framework of Tsallis statistics might offer new methodologies for data analysis. For instance, it could be useful in understanding the dynamics of ecosystems, population genetics, or the spread of diseases, where traditional models might not fully capture the underlying processes due to their complexity and the presence of long-range interactions.</p> <p>To explore this possibility further, one could start by investigating specific biostatistical problems where the assumptions of traditional statistical mechanics are not met, and then applying Tsallis statistics to see if it offers better predictive power or insights. It would also be beneficial to collaborate with experts in biostatistics to identify the most pressing challenges where Tsallis statistics could be applied.</p> <p>While the application of Tsallis statistics to biostatistics is an intriguing prospect, it is an emerging area that would require substantial interdisciplinary research to fully understand its potential and limitations. Below is a list of potential applications, which is to be taken with a grain of salt.</p> <ol> <li> <p><strong>Epidemiological Modeling</strong>: Tsallis statistics could be used to model the spread of diseases, especially in cases where traditional models fail to capture the long-range correlations between individuals in a population.</p> </li> <li> <p><strong>Genetic Data Analysis</strong>: Analysis of genetic sequences and variations, where non-extensive entropy might better capture the complexity and long-range dependencies within genetic information.</p> </li> <li> <p><strong>Protein Folding Dynamics</strong>: Investigating the non-linear dynamics of protein folding, where Tsallis statistics may offer insights into the anomalous diffusion processes involved.</p> </li> <li> <p><strong>Neural Network Analysis</strong>: Modeling the complex interactions within neural networks, particularly in understanding the non-linear dynamics of brain activities and signal transmissions.</p> </li> <li> <p><strong>Ecological Systems</strong>: Applying Tsallis statistics to model the complexity of ecological systems, where interactions can span vast spatial and temporal scales.</p> </li> <li> <p><strong>Cancer Growth Modeling</strong>: Understanding the anomalous growth patterns of tumors, where traditional models might not accurately capture the underlying dynamics.</p> </li> <li> <p><strong>Drug Response Modeling</strong>: Analyzing the variability in drug responses among populations, which may exhibit non-standard distribution patterns that Tsallis statistics could elucidate.</p> </li> <li> <p><strong>Heart Rate Variability Analysis</strong>: Investigating the complex, non-linear dynamics of heart rate variability, potentially uncovering new insights into cardiovascular health.</p> </li> <li> <p><strong>Analysis of Medical Imaging Data</strong>: Enhancing the interpretation of complex patterns in medical imaging, such as MRI or CT scans, through non-extensive statistical models.</p> </li> <li> <p><strong>Public Health Data Analysis</strong>: Applying Tsallis statistics to public health data, potentially uncovering new patterns or correlations in large-scale health trends.</p> </li> </ol> <hr> <h2 id="11-the-basics-of-boltzmann-gibbs-extensive-entropy">1.1. The Basics of Boltzmann-Gibbs Extensive Entropy</h2> <p><em>The whole theory of Tsallis statistics is based on a single concept: the modified Boltzmann-Gibbs (B-G) entropy</em> $S_ {q}$. $q$ is some index show how much $S_ {q}$ differs from the $BG$ entropy, if $q=1$ then there is no difference.</p> <p>To explain why the Boltzmann-Gibbs entropy is said to be additive, let’s first clarify what we mean by entropy in this context. In statistical mechanics, the Boltzmann-Gibbs entropy is a measure of the number of microstates that correspond to a given macrostate, providing a quantification of the system’s disorder or randomness.</p> <p>The formula for Boltzmann-Gibbs entropy, $S$, for a system in a particular <strong>macrostate</strong> is given by:</p> \[S = -k_B \sum_i p_i \ln p_i\] <p>where $p_i$ is the probability of the system being in the $i$-th microstate, and $k_B$ is the Boltzmann constant.</p> <p>Entropy is said to be additive when, for two independent systems $A$ and $B$, the total entropy $S_{AB}$ of the combined system is the sum of their individual entropies:</p> \[S_{AB} = S_A + S_B\] <p>This additivity property stems from the assumption of statistical independence of the two systems, which implies that the probability of the combined system $AB$ being in a particular microstate is the product of the probabilities of $A$ and $B$ being in their respective microstates. If $A$ is in a microstate with probability $p_i$ and $B$ is in a microstate with probability $q_j$, then the probability of the combined system being in the microstate characterized by both $p_i$ and $q_j$ is $p_i \cdot q_j$.</p> <p>As an example, consider two independent systems $A$ and $B$, each with two possible microstates. For system $A$, let the probabilities of the microstates be $p_1$ and $p_2$, and for system $B$, let them be $q_1$ and $q_2$. The entropies of systems $A$ and $B$ are:</p> <p>\(S_A = -k_B (p_1 \ln p_1 + p_2 \ln p_2)\) \(S_B = -k_B (q_1 \ln q_1 + q_2 \ln q_2)\)</p> <p>For the combined system $AB$, there are four possible microstates, with probabilities $p_1q_1, p_1q_2, p_2q_1,$ and $p_2q_2$. The entropy of the combined system is:</p> \[S _{AB} = -k_B [(p_1q_1) \ln (p_1q_1) + (p_1q_2) \ln (p_1q_2) + (p_2q_1) \ln (p_2q_1) + (p_2q_2) \ln (p_2q_2)]\] <p>With some algebra, you can show that:</p> \[S_{AB} = S_A + S_B .\] <p>This demonstrates the additivity of entropy for independent systems. <em>The crucial point here is the assumption of independence</em>, which allows the probabilities of the combined system to be expressed as products of the individual systems’ probabilities, leading directly to the additivity of entropy.</p> <p>Tsallis in his book compared his generalization of B-G statistics to $q$-statistics to the generalization of a circle to ellipses in explaining the motion of celestial objects. In both cases a single parameter changes everything. However I would argue that in the case of Kepler and others, more physics was revealed then in Tsallis’ case.</p> <h2 id="12-generalization-to-non-extensive-entropy">1.2. Generalization to non-Extensive entropy</h2> <p>In his book Tsallis listed some reasons for considering non-extensive, non-Boltzmann-Gibbs entropy, which can be roughly translated into:</p> <ol> <li>There is no (mathematical or physical) reason not to.</li> <li>A statistical description of a system should be based on the dynamics of the system, the macroscopic theory should come from a microscopic one. This opens the way, especially for complex systems, for other than Boltzmann statistics.</li> <li>The existence of long-range interactions on the microscopic level.</li> </ol> <h1 id="2-boltzmann-gibbs-statistical-mechanics">2. Boltzmann-Gibbs Statistical Mechanics</h1> <h2 id="21-three-different-forms-of-bg-entropy">2.1. Three different forms of BG entropy</h2> <p>No we need to come back to one of the most important concept in physics, statistics and information theory: <strong>entropy</strong>. It appears in various fields, each with its unique perspective but underlying similarities in concept.</p> <p>Generally, <em>entropy represents a measure of disorder, randomness, or uncertainty</em>. In statistics, entropy is a measure of the <strong>unpredictability</strong> or the <strong>randomness</strong> of a distribution. <em>The higher the entropy, the more unpredictable the outcome</em>. For example, in a perfectly uniform distribution where all outcomes are equally likely, entropy is at its maximum, indicating maximum uncertainty or disorder. In contrast, a distribution where one outcome is certain has zero entropy, representing complete order. This concept is used in various statistical methods and models to quantify uncertainty or variability within a dataset. In information theory, entropy is a fundamental concept introduced by <code class="language-plaintext highlighter-rouge">Claude Shannon</code>. It quantifies the average amount of information produced by a stochastic source of data. The more uncertain or random the source, the higher the entropy. In practical terms, entropy helps in understanding the limits of data compression and the efficiency of communication systems. For instance, a message composed of completely random bits has higher entropy and cannot be compressed beyond a certain limit without losing information. On the other hand, a message with a lot of repetitive or predictable parts has lower entropy and can be compressed more effectively.</p> <p>In each of these fields, entropy helps us understand systems’ behavior in terms of unpredictability, disorder, and efficiency. While the context and applications may vary, the core idea revolves around the concepts of uncertainty and the distribution of states or outcomes.</p> <p>In the previous section we showed the definition of entropy without much justification, because there is none! Not from the first principal at least. The programme to derive the expression of entropy that we are using today is sometimes called the Boltzmann program, since that was what Boltzmann was trying to do, before he strangled himself to death using a curtain or something.</p> <p>However, if the possibilities is a continuous distribution, the BG entropy must be modified accordingly, discrete probability $p_ {i}$ must be replaced by probability density $p(x)$ where $x$ is the variable. As a naively guess, I would say that we can write the entropy as</p> \[-k \sum p _ {i} \ln p _ {i} \to -k \int dx \, p(x) \ln(p(x)),\] <p>where the probability distribution function (or probability density) is normalized,</p> \[\int dx \, p(x) =1.\] <p>However, a difference between discrete and continuous probability lies in its dimension! Normalized discrete probabilities $p_ {i}$ sums to 1, $\sum_ {i} p_ {i}=1$, since $1$ is dimensionless, so is $p_ {i}$. This is not true for continuous probability density $p(x)$, since now the normalization condition tells us that $\int dx \, p(x)$ should be dimensionless, and $dx$ has the dimension of length, so $p(x)$ must have dimension of length inversed! Thus, wo need to introduce another parameter, call it $\sigma$, with dimension of length. Then we can define the BG entropy in the continuous scenario:</p> \[S_ {BG} = -k\int dx \, p(x) \ln(\sigma\, p(x)).\] <p>For the case of equal probabilities, that is, $p= 1 / \Omega$ where $\Omega$ is the total number of allowed microscopic states, we have</p> \[S_ {BG} = k \ln\left( \frac{\Omega}{\sigma} \right).\] <p>We just mention on the fly that, in quantum mechanics, the probabilistic distribution of a mixed state in terms of pure states is described using the density matrix $\rho$, and the BG entropy is generalized to</p> \[S_ {BF} = -k\,\mathrm{Tr}\, (\rho \ln \rho).\] <h2 id="22-properties-of-bg-entropy">2.2. Properties of BG entropy</h2> <p>We will list without proof some of the key properties of BG entropy.</p> <ul> <li> <strong>Non-negativity</strong>. $S\geq 0$ always. $S = k\ln \Omega$ might help to convince you of it.</li> <li> <strong>BG entropy is maximized at equal probability</strong>. Anything that drives the system away from it will decrease the entropy.</li> <li> <strong>Expansibility</strong>. Adding to a system new possible states with zero probability should not modify the entropy.</li> <li> <strong>Additivity</strong>. Let $A,B$ be two systems with entropy $S(A)$ and $S(B)$, putting them together will result in a new system $A+B$ with entropy $S(A+B)=S(A)+S(B)$.</li> <li> <strong>Concavity</strong>. Given two different probability distributions $\left\lbrace p_ {i} \right\rbrace$ and $\left\lbrace p’_ {i} \right\rbrace$, we can define an intermediate probability distribution</li> </ul> \[\widetilde{p}:= \lambda p + (1-\lambda)p',\quad \lambda \in (0,1).\] <p>Then we have</p> \[S(\widetilde{p})\equiv S(\lambda)&gt; \lambda S(p)+(1-\lambda)S(p').\] <p><strong>Shannon Uniqueness Theorem</strong>.</p> <p>In his work, Shannon was interested in finding a measure that could quantitatively capture the information content of a message source. He proposed several properties that this measure (which we now call entropy) should satisfy to be a useful and consistent measure of information. These properties included:</p> <ol> <li> <strong>Additivity</strong>: The entropy of two independent sources should be the sum of their individual entropies.</li> <li> <strong>Continuity</strong>: The measure should change continuously as the message probabilities change.</li> <li> <strong>Symmetry</strong>: The measure should not depend on the order of the messages.</li> <li> <strong>Maximum</strong>: The measure should be maximal for a uniform distribution, where all messages are equally likely.</li> </ol> <p>Shannon’s Uniqueness Theorem essentially states that, given these properties (along with a few others), the entropy of a discrete random variable is unique and is given by the now-familiar formula:</p> \[S = -\sum_{i} p(x_i) \ln p(x_i)\] <p>The theorem’s significance lies in its establishment of entropy as a <strong>unique measure</strong> that satisfies these intuitive and necessary properties for quantifying information. It solidified the concept of entropy as the foundational metric in information theory, leading to profound implications for communication, coding theory, and even other disciplines like statistics and thermodynamics.</p> <h2 id="23-constraints-and-entropy-optimization">2.3. Constraints and Entropy Optimization</h2> <p><strong>Imposing the Mean Value</strong></p> <p>We might know a priori the mean value of a variable $x$, i.e.</p> \[\left\langle x \right\rangle := \int dx \, x \, p(x) = \overline{x} \quad \text{ is known.}\] <p>We can apply the Lagrange multiplier method to find the optimizing distribution with the constraint, together with the normalization condition $\int dx \, p(x)=1$. The Lagrangian functional that we want to extremize reads</p> \[\Phi[p(x)] = S_ {BG} - \alpha \int dx \, p(x) - \beta \int dx \, x \, p(x)\] <p>where we have neglected some constant terms since they don’t appear in the Euler-Lagrange equation, that is to say, they don’t affect the final result; and</p> \[S_ {BG} = -\int dx \, p(x)\ln p(x).\] <p>Using the method of variation, we get</p> \[p(x) = \frac{1}{\overline{x}} e^{ -x / \overline{x} }.\] <p><strong>Imposing the Mean value and the Mean Squared Value</strong></p> <p>Supposed that we not only know the mean value $\overline{x}=\left\langle x \right\rangle$, but also the mean square value $\left\langle x^{2} \right\rangle$:</p> \[\left\langle x^{2} \right\rangle \equiv \int dx \, (x-\left\langle x \right\rangle )^{2} p(x)\] <p>This time the Lagrangian reads</p> \[\Phi[p(x)] = S_ {BG} - \alpha \int dx \, p(x) - \beta_ {1}\int dx \, xp(x) - \beta_ {2} \int dx \, (x-\left\langle x \right\rangle )^{2}p(x).\] <p>Exactly as before, the variational method gives us</p> \[p(x) = \sqrt{ \frac{\beta_ {2}}{\pi} } \exp \left\lbrace -\beta_ {2}(x-\left\langle x \right\rangle )^{2} \right\rbrace\] <p>which is just the Gaussian distribution! This tells us that the Gaussian distribution maximizes the entropy with fixed mean and variance.</p> <h1 id="3-nonextensive-statistical-mechanics">3. Nonextensive Statistical Mechanics</h1> <p>Tsallis is convinced that there exists no logical-deductive procedure for generalizing any physical theory. As a possible motivation to generalize the exponential function $e^{ x }$, he started from the equation that $e^{ x }$ satisfies, which is fairly simple:</p> \[\frac{dy}{dx} = y.\] <p>A possible generalization of the equation is to writhe the RHS as $a+by$, we have</p> \[\frac{dy}{dx} = a+by \implies \frac{dy}{a+by}=dx\implies y=\frac{1}{b}(e^{ b(x+c) }-a),\] <p>which does not look very promising. Then Tsallis considered a non-linear generalization:</p> \[\frac{dy}{dx} = y^{q}, \quad q\in \mathbb{R},\quad y(0)=1.\] <p>The boundary condition $y(0)=1$ is such that is agrees with the usual exponential function $e^{ 0 }=1$. Solving it we get</p> <p>\((1-q) (x+c) = y^{1-q} ,\) the boundary condition translates to</p> \[c = \frac{1}{1-q},\] <p>thus</p> \[\boxed{ y = (1+(1-q)x)^{1/(1-q)} =: \exp_ {q}(x). }\] <p>When $1+(1-q)x&lt;0$, $e_ {q}(x)$ is defined to be zero (<strong>why don’t complexify it</strong>?). Also note that $e^{ x }_ {q}$ goes to $e^{ x }$ at $q\to 1$ since, writing $q = 1-\epsilon$, we have</p> \[\lim_ { q \to 1 } e^{ x }_ {q} = \lim_ { \epsilon \to 0 } (1+\epsilon x)^{1/\epsilon} = e^{ x }.\] <p>From the same equation that we got the definition of $e^{ x }_ {q}$, we also get the inverse function of $x$ in terms of $y$:</p> \[\boxed{ x = \frac{y^{1-q}-1}{1-q} =: \log_ {q} y. }\] <p>They are referred to as $q$-exponential functions and $q$-logarithmic functions respectively.</p> <p>Recall that logarithmic functions turns multiplication into addition, $\log(AB)=\log(A)+\log(B)$, for $q$-logarithmic functions we have something similar,</p> \[\log_ {q}(AB) = \log_ {q}(A) + \log_ {q}(B) + (1-q) \log_ {q}(A)\log_ {q}(A).\] <h2 id="31-mean-value-in-tsallis-statistics">3.1. Mean Value in Tsallis Statistics</h2> <p>The Tsallis entropy is defined as</p> \[S_ {q} = \frac{1}{q-1} \sum_ {i} (p_ {i}-p_ {i}^{q}) = - \sum_ {i} p_ {i} \ln_ {q} p_ {i}\] <p>There are at least three types of Tsallis statistics, depending on how they take the mean value. Next we will discuss each of them in chronological order.</p> <p>Throughout the note we will assume that probabilities are normalized to one,</p> \[\sum_ {i} p_ {i} = 1.\] <p>Given an observable $\mathcal{O}$, what is the expected value $\left\langle \mathcal{O} \right\rangle$? In regular statistics</p> \[\left\langle \mathcal{O} \right\rangle := \sum_ {i} p _ {i} O_ {i}\] <p>where $\mathcal{O}_ {i}$ is the $i$-th possible value of $\mathcal{O}$ with probability $p_ {i}$. However, this definition yields an ill-defined thermodynamic distribution, <em>some energy states will not be allowed due to mathematical rather than physical reasons, and the distribution is not invariant under an overall shift in energy</em>. Normally only the energy difference matter, the only situation that I know of where the absolute energy matters is from gravity, which is clearly not the case here. Thus it is not a good definition in Tsallis statistics.</p> <hr> <p>Another way to define the average, known as Tsallis type II, is</p> <p>\(\left\langle \mathcal{O} \right\rangle := \sum_ {i} p_ {i}^{q} \mathcal{O}_ i.\) The problem is similar with type I, the sample space is constraint due to some un-natural reason, which I tend to interpret as the evidence of an ill-defined theory. Some divergence that occurs in type I does not occur here, but it introduces new problems, most of all the expected value of unity $\mathbb{1}$ is not $1$.</p> <p>However there is a remedy. Arguing from the point of view of information theory on incomplete probability distributions, Q. A. Wang suggested modifying the normalization of probability as</p> \[\sum_ {i} p_ {i}^{q} = 1.\] <p>This can be rewritten by defining $P_ {i}:= p_ {i}^{1}$, then</p> \[\left\langle \mathcal{O} \right\rangle := \sum_ {i} P_ {i} \mathcal{O}_ {i} .\] <hr> <p>Type III assumes that the average is defined as type II but with an normalization factor:</p> \[\left\langle \mathcal{O} \right\rangle := N \sum_ {i} p_ {i}^{q}\mathcal{O}_ {i},\quad N = \sum_ {i}p_ {i}.\] <p>This solves the problem that the expectation value of identity $1$ is not $1$. The probability derived from is also becomes invariant under an overall shift.</p> <h1 id="4-tsallis-in-logistic-regression-methods">4. Tsallis in Logistic Regression Methods</h1> <p>This part will be presented in a much less pedagogical way, we will simply introduce new functions and concepts along the way.</p> <p>Before I could apply Tsallis statistics to medical data, I need first to figure out how the traditional method works.</p> <h2 id="41-traditional-logistic-regression-method">4.1 Traditional logistic regression method</h2> <p>Consider a matrix $X_ {n \times p}$ representing the expression of $p$ genes from $n$ samples, obtained through technologies like microarray or RNA-seq. Here, $p \gg n$, hence the name <em>big $p$, small $n$</em> problem. The response, or dependent variables (observables), is denoted by an $n$-vector $\vec{y} = (y_ 1, \cdots, y_ n)$. Each $y_ i$ is a binary variable, taking values 0 or 1. For example, in a clinical context, think of each sample as a patient; $y_ i = 1$ might indicate that patient $i$ is cured of, or has, a certain disease, while $y_ i = 0$ indicates the opposite. Currently, we are focusing on a mathematical model, so the exact biological or clinical significance of $y = 1$ is not specified. The values of $\vec{y}$ follow a Bernoulli distribution, which will be discussed in more detail shortly.</p> <p>We can organize all the gene expressions from all the samples into a single matrix $X$,</p> \[X = \begin{pmatrix} x_ {11} &amp; \cdots &amp; x_ {1p} \\ x_ {21} &amp; \cdots &amp; x_ {2p} \\ \vdots &amp; \ddots &amp; \vdots \\ x_ {n1} &amp; \cdots &amp; x_ {np} \end{pmatrix}.\] <p>In the above matrix, each row is a vector of different genes from one sample, while each column represents one type of gene from different patients. We use $X_ {i}$ to denote the expression of the $i$-th gene across $n$ samples, which corresponds to the $i$-th column of $X$. Conversely, $(X_ {(j)})^{T}$ represents the genes expression observed in $j$-th sample (or patient $j$), namely the $j$-th row of $X$. The transpose makes $X_ {(j)}$ a column vector, just like $X_ {a}$. Be aware that the distinction in notation is merely the addition of parentheses. In general, $X$ is our data and $\vec{y}$ will be the dependent variable. In practice, it is known which patients are treated and which are not, hence we know the observed value of $\vec{y}$. The problem is to find a way to <strong>predict</strong> $y_ {a}$ from an observed vector of genes expressions $X_ {(a)}$. But first, we need to know the role played by each gene expressed in different patients, that is, we need to know how to interpret $X_ {a}$ for gene $a$. For example, if $X_ {a}$ is a constant vector for all the patients, then we know that gene $a$ most likely has nothing to do with the disease of study.</p> <hr> <p>Let us now delve into the mathematical foundations of the model.</p> <p>Let $\pi_ {i}$ be the probability of $y_ {i}=1$, which we aim to predict. Following the standard logistic regression method, we define the logit (log here is used as a verb, <strong>log</strong>-it) function of $\pi_ {i}$,</p> \[\text{logit}(\pi_ {i} ) := \ln\left( \frac{\pi_ {i}}{1-\pi_ {i}} \right), \quad \text{logit}: [0,1]\to \mathbb{R}.\] <p>$\pi$ is the probability, and $\pi / (1-\pi)$ is called <code class="language-plaintext highlighter-rouge">odd</code> with range $\mathbb{R}^{+}:=[0,\infty)$. Note that in our convention zero is included in $\mathbb{R}^{+}$.</p> <p>Since we have constructed a continuous function $\text{logit}(\pi)$ from a probability function $\pi$, we can now adopt familiar <em>linear regression method</em> and apply it to the logit function. Parametrize the logit function in a linear form</p> \[\text{logit}(\pi_ {i}) := \beta_ {0}+X_ {(i)}\cdot\beta, \quad \beta=(\beta_ {1},\cdots,\beta_ {p}).\] <p>$\beta$ is the parameter vector to be fixed later. Note the dot product is the product between vectors, $X \cdot \beta:= X^{T} \beta$ .</p> <p>Direct derivation shows that</p> \[\pi_ {i} = \frac{1}{1+\exp(-\beta_ {0}-X_ {(i)}\cdot \beta)}=:\text{sigm}(\beta_ {0}+X_ {(i)}\cdot \beta),\] <p>where $\text{sigm}$ stands for sigmoid function, which literally means a function that has an $S$-shape. In our particular case the sigmoid function is give by</p> \[\text{sigm}(t) := \frac{1}{1+e^{ -t }}.\] <p>Note that $\text{sigm}$ is the inverse of $\text{logit}$,</p> \[\text{logit}(\pi)=x \Longleftrightarrow \pi = \text{logit}^{-1}(x) = \text{sigm}(x).\] <p>I am not sure if there exists other widely-applied definitions for sigmoid function except for that given above. There surely are other functions with an S-shape, such as tanh and arctan, but I am not sure if they can be called sigmoids? Or maybe difference in the predictive power by introducing different choices of sigmoid functions are negligible, hence it only makes sense that we stuck with the simplest option?</p> <p>Now, the question is how can we fix the parameters? The natural answer is: by maximizing the likelihood, or equivalent by minimizing the loss function. The likelihood function, by definition, is the probability (likelihood) for a certain observation $\vec{y}$. This function gives the probability of observing the given data within certain model, with some free parameters. For instance, supposed there are three samples (binary), then the likelihood of $y=(1,0,1)$ corresponds to the probability predicted by our model that the first and third patients have got some disease, while the second does not. Now, the probability for each $y_ {i}=1$ is $\pi_ {i}$, which is by definition $\text{sigm}(t_ {i})\equiv1/(1-e^{ -t_ {i} })$, where $t=\beta_ {0}+X_ {(i)}\cdot \beta$, and $\beta$’s are the parameters. The probability for $y_ {i}=0$ is $1- 1/(1-e^{ -ti })$, which is $e^{ -t_ {i} }/(1-e^{ -t_ {i} })$. Then, the likelihood for observing $y=(1,0,1)$ is simply the product of each probability,</p> \[\text{lik}(1,0,1) = \frac{1}{1-e^{ -t_ {1} }} \frac{e^{ -t_ {2} }}{1-e^{ -t_ {2} }} \frac{1}{1-e^{ -t_ {3} }},\] <p>which is a function of observed gene expression $X_ {(i)}$ with parameters $\beta$’s.</p> <p>Likelihood function can also be written using the <code class="language-plaintext highlighter-rouge">Bernoulli distribution</code> function, which is a probability distribution function (PDF) that has only two possible outcomes, 1 and 0, with probability $\pi$ for $y=1$ and $1-\pi$ for $y=0$. This distribution is a special case of the binomial distribution where the number of trials $n$ is equal to 1. The <strong>Probability Mass Function (PMF)</strong> of Bernoulli distribution is defined as</p> \[P(y) := \pi^y (1-\pi)^{1-y}, \quad y=0 \text{ or }1,\] <p>where $\pi$ is given <em>a priori</em>. The Expected Value is $\left\langle y \right\rangle=\pi$ and the variance is $\text{Var}(y) = \pi(1-\pi)$, you can verify it easily. This neat expression unites both cases $y=0$ and $y=1$. Applying it to the likelihood function we get</p> \[\text{lik}(1,0,1) = \prod_ {i=1}^{3} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}}, \quad \vec{y}=(1,0,1).\] <p>Generalization to arbitrary $\vec{y}$ is trivial,</p> \[\text{lik}(\vec{y}) := \prod_ {i=1}^{n} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}}, \quad \vec{y}=(y_ {1},\cdots,y_ {n}).\] <p>The above expression can be further simplified using logarithms. Recall that logarithm is a <em>monotonically increasing</em> function, it means that $\log(\text{lik}(\vec{y}))$ is maximized iff (if and only if) $\text{lik}(\vec{y})$ is maximized. The reason why it is a good idea to take the logarithm of the likelihood is the following.</p> <ol> <li> <p><strong>Numerical Stability</strong>: The likelihood function in models like logistic regression involves products of probabilities, which can be very small numbers. When multiplying many such small probabilities, the result can become extremely small, potentially leading to numerical underflow (where values are so small that the computer treats them as zero). The logarithm of these small numbers turns them into more manageable, larger negative numbers, reducing the risk of numerical issues.</p> </li> <li> <p><strong>Simplification of Products into Sums</strong>: The likelihood function involves taking the product of probability values across all data points. In contrast, the log-likelihood converts these products into sums by the property of logarithms $\ln(ab) = \ln(a) + \ln(b)$. Sums are much easier to handle analytically and computationally. This is especially useful when dealing with large datasets.</p> </li> <li> <p><strong>Convexity Properties</strong>: The log-likelihood function often yields a convex optimization problem in cases where the likelihood itself is not convex. Convex problems are generally easier to solve reliably and efficiently. For logistic regression, the log-likelihood function is concave, and finding its maximum is a well-behaved optimization problem with nice theoretical properties regarding convergence and uniqueness of the solution.</p> </li> <li> <p><strong>Derivative Computation</strong>: The derivatives of the log-likelihood (needed for optimization algorithms like gradient ascent or Newton-Raphson) are typically simpler to compute and work with than the derivatives of the likelihood function. This simplicity arises because the derivative of a sum (log-likelihood) is more straightforward than the derivative of a product (likelihood).</p> </li> </ol> <p>Last but not least,</p> <ol> <li> <strong>Possibility to introduce the Tsallis statistics</strong>: We have explain how the Tsallis statistics modified traditional exponential and logarithmic functions, <em>in our case the log-likelihood function can be generalized by adopting the Tsallis logarithm, namely $\log_ {q}$.</em> In the next section we will try to explain the advantage of such generalization, which will also serve as justification. But of course, being a phenomenological model, the true justification will be the power of prediction, which can only be tested in real-life practice.</li> </ol> <p>But for now, let’s forget about Tsallis and carry on on the road of conventional logic regression method.</p> <p>Taking the natural log of likelihood function gets us</p> \[\begin{align*} \text{loglik}(\vec{y}) &amp;:=\log(\text{lik}(\vec{y}))= \ln \left\lbrace \prod_ {i=1}^{n} \pi_ {i}^{y_ {i}}(1-\pi_ {i})^{1-y_ {i}} \right\rbrace \\ &amp;=\sum_ {i} \left\lbrace y_ {i} \ln\pi_ {i}+(1-y_ {i}) \ln(1-\pi_ {i}) \right\rbrace. \end{align*}\] <p>In the context of logistic regression, people often use the <code class="language-plaintext highlighter-rouge">loss function</code>, <em>defined as the negative of the likelihood function</em>. This is primarily due to convention and practical considerations in optimization processes, since most optimization algorithms and tools are designed to minimize functions rather than maximize them. This is a common convention in mathematical optimization and numerical methods. Since maximizing the likelihood is equivalent to minimizing the negative of the likelihood, formulating the problem as a minimization problem allows us the application of standard, widely available optimization software and algorithms without modification. In many statistical learning methods, the objective function is often interpreted as a “cost” or “loss” that needs to be minimized. When working with a loss function, the goal is to find parameter estimates that result in the smallest possible loss. Defining the loss function as the negative log-likelihood aligns with this interpretation because lower values of the loss function correspond to higher likelihoods of the data under the model.</p> <p>Furthermore, using a loss function that is to be minimized creates a consistent framework across various statistical learning methods, many of which inherently involve minimization (like least squares for linear regression, and more complex regularization methods in machine learning). This consistency is helpful not only from an educational and conceptual standpoint but also from a practical implementation standpoint.</p> <p>A <code class="language-plaintext highlighter-rouge">regularized loss function</code> is the loss function with <code class="language-plaintext highlighter-rouge">penalty terms</code>. Penalty terms in regression methods are essential for managing several challenges that arise in statistical modeling, particularly with high-dimensional data. These challenges include <em>overfitting</em>, <em>multicollinearity</em>, and <em>interpretability</em>.</p> <p>One of the primary reasons for using penalty terms is to prevent overfitting. Overfitting occurs when a model captures not just the true underlying pattern but also the random fluctuations (noise) in the data. This makes the model very accurate on the training data but <em>poorly generalized to new, unseen data</em>. By adding a penalty term, which increases as the model complexity increases (e.g., as coefficients become larger), the optimization process is biased towards simpler models. This helps to ensure that the model generalizes well to new data by focusing on the most significant predictors and shrinking the others.</p> <p>Multicollinearity occurs when two or more predictor variables in a regression model are highly correlated. This can make the model estimation unstable and the estimates of the coefficients unreliable and highly sensitive to small changes in the model or the data. Penalty terms, especially those like Lasso regression (L1 penalty) or Ridge regression (L2 penalty), can reduce the impact of multicollinearity by penalizing the size of the coefficients, thus stabilizing the estimates. In high-dimensional datasets where the number of predictors $p$ exceeds the number of observations $n$ or when there are many irrelevant features, selecting the most relevant features becomes crucial. Lasso regression (L1 penalty) is particularly useful for this purpose because it can shrink some coefficients to exactly zero, effectively performing variable selection. This helps in identifying which predictors are most important for the outcome, simplifying the model and improving interpretability.</p> <p>By shrinking coefficients or reducing the number of variables, penalty terms help in simplifying the model. A simpler model with fewer variables or smaller coefficients is easier to understand and interpret. This is particularly valuable in domains like medical science or policy-making, where understanding the influence of predictors is as important as the prediction itself.</p> <p>However it is also important to realize the disadvantages of introducing penalty terms, that is the bias-variance tradeoff. Adding a penalty term introduces bias into the estimator for the coefficients (the estimates are “shrunk” towards zero or towards each other in the case of Ridge). However, this can lead to a significant reduction in variance (the estimates are less sensitive to fluctuations in the data). This trade-off can lead to better predictive performance on new data, which is the ultimate goal of most predictive modeling tasks.</p> <hr> <p>In our project, we consider the regularized loss function as following.</p> \[l(\beta_ {0}, \vec{\beta}) := -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\pi_ {i})+(1-y_ {i})\ln(1-\pi_ {i}) \right\rbrace +h(\vec{\beta}),\] <p>where $h(\vec{\beta})$ is the penalty terms and is independent of $\beta_ {0}$, which is simply a shift. $h(\vec{\beta})$ could be the Lasso (<code class="language-plaintext highlighter-rouge">Least Absolute Shrinkage and Selection Operator</code>) term, or ridge term.</p> <hr> <p>We now introduce the <strong>Group Lasso regression</strong> method. Group Lasso regression is an extension of Lasso that is particularly useful in the context of biostatistics, especially when dealing with models that incorporate multiple predictors which naturally group into clusters. This method not only encourages sparsity in the coefficients, like traditional Lasso, but also takes into account the structure of the data by promoting or penalizing entire groups of coefficients together. Here’s an introduction to how Group Lasso works and why it’s valuable in biostatistics:</p> <p>In many biostatistical applications, predictors can be inherently grouped based on biological function, measurement type, or other domain-specific knowledge. For example, genes might be grouped into pathways, or clinical measurements might be grouped by the type of instrument used or the biological system they measure.</p> <p>The key idea behind Group Lasso is to <em>perform regularization and variable selection at the group level</em>. The formulation of Group Lasso is similar to that of Lasso, but instead of summing the absolute values of coefficients, it sums the norms of the coefficients for each group. The objective function for Group Lasso can be written as:</p> \[\text{Minimize:} \quad \text{loss function} + h(\vec{\beta}), \quad h(\vec{\beta}):= \lambda \sum_ {g=1}^G w_ g \left\lVert \vec{\beta}_{(g)} \right\rVert_ {2}\] <p>where $\vec{\beta}$ represents the coefficient vector, $\vec{\beta}_ {(g)}$ is the sub-vector of coefficients corresponding to group $g$. Note the difference between $\beta_ {g}$ and $\beta_ {(g)}$, the former is a component of $\vec{\beta}$ thus a number, while the latter is a sub-vector of $\vec{\beta}$. $G$ is the total number of groups, $w_g$ are weights that can be used to scale the penalty for different groups, often based on group size or other criteria, $\left\lVert \vec{\beta}_ {(g)} \right\rVert$ is typically the Euclidean norm (L2 norm) of the coefficients in group $g$ or, as is shown in ShunJie’s paper, the PCC (Pearson correlation coefficient) distance, or shape-based distance. $\lambda$ is a <strong>global</strong> tuning parameter that controls the overall strength of the penalty.</p> <p>In our current project, we use square root of the degree of freedom (dof) as the weight for different groups. The penalty term is then</p> \[h(\beta) = \lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} } \left\lVert \vec{\beta}_ {g} \right\rVert _ {2} =: \lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} }\; r_ {g}\] <p>where $d_ {g}$ is the number of genes in group $g$, or dimension of $\vec{\beta}_ {g}$, $\vec{\beta}_ {g}$ is treated as a $d_ {g}$-vector of parameters, and $r_ {g}$ is the radius of $\vec{\beta}_ {g}$. Naturally it is a subset of $\beta$.</p> <p>Recall that $\sqrt{ d_ {g} }$ is the expected length of $d_ {g}$ i.i.d. variables, independent and identically distributed variables. The factor $\sqrt{d_ g}$ is to adjust for the size of each group, it scales up the penalty proportional to the group size. This means that larger groups, which naturally have a potentially larger norm due to more coefficients, receive a proportionally larger penalty. By multiplying the norm by $\sqrt{d_ g}$, the intention is to make the penalty fair by ensuring that the regularization is proportional to the number of parameters in the group. Without this scaling, smaller groups could be unfairly penalized in relative terms because their norms are naturally smaller due to fewer components. For example, consider two groups in a regression setting:</p> <ul> <li>Group 1: Contains 1 coefficient, $\mathbf{w}_ 1 = (3)$.</li> <li>Group 2: Contains 4 coefficients, $\mathbf{w}_ 2 = (1, 1, 1, 1)$.</li> </ul> <p>Without any normalization, we have</p> <ul> <li>The norm for Group 1 is $\left\lVert w_ {1} \right\rVert_ 2 = \left\lvert 3 \right\rvert = 3$.</li> <li>The norm for Group 2 is $\left\lVert w_ {2} \right\rVert_ 2 = \sqrt{1^2 + 1^2 + 1^2 + 1^2} = 2$.</li> </ul> <p>Here, the raw norms suggest that Group 1 might be more significant, which could distort the model’s view. Using $d_ g$ for normalization instead, we have:</p> <ul> <li>For Group 1: $1 \times \left\lvert 3 \right\rvert= 3$.</li> <li>For Group 2: $4 \times 2 = 8$.</li> </ul> <p>This overcorrects, making the penalty overly sensitive to the number of components, and could lead to under-penalizing smaller groups. Thus we decide to use $\sqrt{d_ g}$ for normalization:</p> <ul> <li>For Group 1: $\sqrt{1} \times 3 = 3$.</li> <li>For Group 2: $\sqrt{4} \times 2 = 2 \times 2 = 4$.</li> </ul> <p>This balances the penalties more reasonably, reflecting that while Group 2 is larger, its collective contribution should be seen in proportion to the natural growth of norms with group size, not exponentially with each addition.</p> <hr> <p>We recall that $X_ {(i)}$ is the expression of different genes from one patient $i$, in terms of $X_ {(i)}$ is given the probability:</p> \[\pi_ {i} = \frac{1}{1+\exp(-\beta_ {0}-X_ {(i)}\cdot \beta)}=\text{sigm}(\beta_ {0}+X_ {(i)}\cdot \beta)=\text{sigm}(t_ {i} ),\] <p>where the sigmoid function is give by</p> \[\text{sigm}(t_ {i} ) := \frac{1}{1+e^{ -t_ {i} }}, \quad t_ {i} := \beta_ {0}+X_ {(i)}\cdot \beta.\] <p>The loss function is given by the negative log-likelihood function plus the penalty term, including a punish term:</p> \[\begin{align*} l(\beta) &amp;= -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\pi_ {i})+(1-y_ {i})\ln(1-\pi_ {i}) \right\rbrace +h(\vec{\beta})\\ &amp;= -\sum_ {i}^{n} \left\lbrace y_ {i}\ln(\text{sigm}(t_ {i} ))+(1-y_ {i})\ln(\text{sigm}(-t_ {i} )) \right\rbrace +h(\vec{\beta})\\ &amp;= -\sum_ {i} \left\lbrace y_ {i}\ln\left( \frac{\text{sigm}(t_ {i} )}{\text{sigm}(-t_ {i} )} \right) + \ln\, \text{sigm}(-t_ {i} ) \right\rbrace + h(\beta) \\ &amp;= -\sum_ {i}[y_ {i}t_ {i} -\ln(1+e^{ t_ {i} })] + h(\beta)\\ &amp;=: J(\beta)+h(\beta), \end{align*}\] <p>where in the first line we have exploit the fact that the sigmoid function is symmetric, and write $l(\vec{\beta})$ in terms of sigmoid function for future convenience. To be specific, in future work we will consider generalization for sigmoid function with Tsallis q-logarithms, so we might just write the loss functions explicitly in terms of it as well. $h(\beta)$ is the Lasso penalty term given by $\lambda \sum_ {g=1}^{G} \sqrt{ d_ {g} } \left\lVert \vec{\beta}_ {g} \right\rVert _ {2}$. $J(\beta)$ is the minus likelihood function,</p> \[\boxed{ J(\beta):= -\sum_ {i}[y_ {i}t_ {i} -\ln(1+e^{ t_ {i} })],\quad t_ {i} =\beta_ {0}+\beta \cdot X_ {(i)}. } ,\] <hr> <p>As usual, the loss function is convex and non-linear. Since we took the absolute value of $\left\lVert \vec{\beta}_ {g} \right\rVert$, it is not smooth at $\vec{\beta}=0$. However it is not a big problem in minimization problem, since it is piece-wise smooth, we simply need to consider the behavior from both sides of the non-smooth point. In the case of a LASSO punish term, that is the origin or each $\vec{\beta}_ {g}$.</p> <p>For Group LASSO regression, the goal is to apply LASSO regularization to groups of coefficients rather than individual coefficients. This means entire groups of variables can be zeroed out together, which encourages group-wise sparsity in the model. The challenge with Group LASSO is the non-differentiability of the regularization term, similar to standard LASSO but applied to norms of groups of coefficients.</p> <p>Several methods can be used to solve the Group LASSO problem efficiently:</p> <ol> <li> <p>Coordinate Descent: This method can still be adapted for Group LASSO by modifying it to work on groups of coefficients rather than individual coefficients. In this context, the update step involves a group soft-thresholding operation, which is a generalization of the soft-thresholding used in standard LASSO.</p> </li> <li> <p><strong>Proximal Gradient Methods</strong>: These are particularly well-suited for Group LASSO due to their ability to handle non-smooth terms efficiently. The proximal operator for the Group LASSO regularization term can be defined explicitly, allowing for straightforward implementation. This method iteratively updates the coefficients by taking a gradient step on the differentiable loss function and then applying the proximal operator to handle the group sparsity.</p> </li> <li> <p><strong>Block Coordinate Descent</strong>: This is a variant of coordinate descent that updates blocks (or groups) of variables at once rather than individual variables. It is particularly useful in Group LASSO, where you want to consider the impact of an entire group of variables together when deciding on updates.</p> </li> <li> <p>Primal-Dual Methods: These methods work by simultaneously updating primal and dual variables to find a solution that satisfies the optimality conditions for both. They can be very efficient for problems like Group LASSO, where the structure of the groups can be exploited to simplify the dual problem.</p> </li> </ol> <p>Among these methods, <strong>Proximal Gradient Methods</strong> and <strong>Block Coordinate Descent</strong> are often the most effective for solving Group LASSO due to their ability to directly handle the group-wise structure and non-smoothness of the regularization term. The choice between these methods may depend on the specific structure of your problem and the size of your data. In the following, we will go through some basic methods leading to the proximal gradient method. For a more detailed introduction see the wonderful online course <a href="https://youtu.be/Clw24Fajnqg?si=9h3i6pSmAqpamLfl" rel="external nofollow noopener" target="_blank">here</a>.</p> <hr> <p><strong>Gradient Descent (GD) method</strong></p> <p>Gradient Descent is an iterative optimization algorithm used to minimize an objective function, which is often used in various statistical and machine learning methods. In biostatistics, it is commonly used for fitting models such as linear regression, logistic regression, and many others.</p> <p>Key Concepts:</p> <ol> <li> <p>Objective Function: The function you want to minimize, usually representing the error or cost associated with the model. For instance, in linear regression, it is the sum of squared errors.</p> </li> <li> <p>Gradient: The gradient of the objective function at a given point indicates the direction of the steepest ascent. Since we want to minimize the function, we move in the opposite direction of the gradient.</p> </li> <li> <p>Learning Rate: A hyperparameter that controls the size of the steps taken to reach the minimum. If it’s too large, the algorithm might overshoot the minimum; if too small, convergence might be slow.</p> </li> </ol> <p>The basic steps of the gradient descent algorithm are:</p> <ol> <li>Initialize: Start with an initial guess for the parameters.</li> <li>Compute Gradient: Calculate the gradient of the objective function with respect to the parameters.</li> <li>Update Parameters: Adjust the parameters in the opposite direction of the gradient.</li> <li>Repeat: Continue until convergence (i.e., when the changes in the parameters become very small).</li> </ol> <p>Mathematically, the update rule for the parameter $\beta$ is:</p> \[\beta^{(t+1)} = \beta^{(t)} - \alpha \nabla f(\beta^{(t)}),\] <p>where $\alpha$ is the learning rate or step length, and $\nabla f(\beta^{(t)})$ is the gradient of the objective function at $\beta^{(t)}$. The derivation of above iteration formula is not as straightforward as, e.g. Newton method, especially it is not clear where the step length comes from. Given a function $f(\beta)$ that we want to minimize, at $\beta^{(k)}$ we are actually approximating it with a quadratic functon</p> \[g(\beta) = f(\beta^{(k)}) + \nabla f(\beta^{(k)})(\beta-\beta^{(k)}) + \frac{1}{2\alpha}(\beta-\beta^{(k)})^{2},\] <p>note we have introduced the step-size parameter $\alpha$ to control the strength of the quadratic term. To find the minimum of $g(\beta)$ around $\beta^{(k)}$, we ask its derivative to be zero, leading to</p> \[g'(\beta) = \nabla f(\beta^{(k)}) + \frac{1}{\alpha} (\beta-\beta^{(k)}) =0\] <p>whose solution reads</p> \[\Delta \beta := \beta-\beta^{(k)} = -\alpha \nabla f(\beta^{(k)}).\] <p>We use $\Delta \beta$ to update $\beta$, namely $\beta^{(k+1)}:= \beta^{(k)}+\Delta \beta$. That’s where the step size parameter comes from. In practice, we usually choose $\alpha=\nabla^{2}f(\beta^{k})$. To make the iteration procedure convergent, there is usually an upper limit for $\alpha$, which is clearly shown in the example of $f(\beta)=\beta^{2}-3\beta+4$, which I’ll skip here, interested readers can take it as a homework.</p> <p>Let’s go through a simple example of fitting a linear regression model using gradient descent. Suppose we have a dataset with $n$ observations and one predictor. The objective function (mean squared error) is:</p> \[f(\beta_ 0, \beta_ 1) = \frac{1}{2n} \sum_ {i=1}^n (y_ i - (\beta_ 0 + \beta_ 1 x_ i))^2,\] <p>where $(x_ i, y_ i)$ are the data points, and $\beta_ 0$ and $\beta_ 1$ are the parameters to be estimated.</p> <ol> <li>Gradient Calculation: <ul> <li>The gradient with respect to $\beta_ 0$ is:</li> </ul> </li> </ol> \[\frac{\partial f}{\partial \beta_ 0} = -\frac{1}{n} \sum_ {i=1}^n (y_ i - (\beta_ 0 + \beta_ 1 x_ i)).\] <ul> <li>The gradient with respect to $\beta_ 1$ is:</li> </ul> \[\frac{\partial f}{\partial \beta_ 1} = -\frac{1}{n} \sum_ {i=1}^n x_ i (y_ i - (\beta_ 0 + \beta_ 1 x_ i)).\] <ol> <li>Update Rules: <ul> <li>Update $\beta_ 0$:</li> </ul> </li> </ol> \[\beta_ 0^{(t+1)} = \beta_ 0^{(t)} - \alpha \frac{\partial f}{\partial \beta_ 0}.\] <ul> <li>Update $\beta_ 1$:</li> </ul> \[\beta_ 1^{(t+1)} = \beta_ 1^{(t)} - \alpha \frac{\partial f}{\partial \beta_ 1}.\] <hr> <p><strong>Subgradient Method</strong></p> <p>The subgradient method is an optimization technique used for minimizing non-differentiable convex functions. It is a generalization of the gradient descent method. Instead of using gradients, it uses subgradients, which are generalizations of gradients for non-differentiable functions. A very nice introduction of subgradients and subdifferential can be found <a href="https://web.stanford.edu/class/ee364b/lectures/subgradients_notes.pdf" rel="external nofollow noopener" target="_blank">here</a>, in the following we only outline the key concepts.</p> <p>Key Concepts:</p> <ol> <li>Subgradient: For a convex function $f$ at a point $x$, a vector $g$ is a subgradient if:</li> </ol> \[f(y) \geq f(x) + g^T (y - x) \quad \text{for all } y \in \mathbb{R}^n.\] <ol> <li> <p>Subdifferential: The set of all subgradients at $x$, denoted $\partial f(x)$.</p> </li> <li> <p>Update Rule: The algorithm iteratively updates the solution using</p> </li> </ol> \[x^{(k+1)} = x^{(k)} - \alpha_ k g^{(k)},\] <p>where $g^{(k)} \in \partial f(x^{(k)})$ and $\alpha_ k$ is the step size.</p> <p>Example: Minimizing $f(x) = \left\lvert x \right\rvert$</p> <ol> <li> <p>Function Definition: $f(x) = \left\lvert x \right\rvert$</p> </li> <li>Subgradient Calculation: <ul> <li>For $x &gt; 0$, $\partial f(x) = { 1 }$</li> <li>For $x &lt; 0$, $\partial f(x) = { -1 }$</li> <li>For $x = 0$, $\partial f(x) = { t \mid -1 \leq t \leq 1 }$</li> </ul> </li> <li>Subgradient Method Steps: <ul> <li>Initialize $x^{(0)} = 2$</li> <li>Choose a step size $\alpha = 0.1$</li> <li>Iterate the update rule:</li> </ul> </li> </ol> \[x^{(k+1)} = x^{(k)} - \alpha \cdot g^{(k)}\] <ul> <li> <p>Suppose $g^{(k)} = 1$ for simplicity.</p> </li> <li> <p>First iteration:</p> </li> </ul> \[x^{(1)} = 2 - 0.1 \cdot 1 = 1.9\] <ul> <li>Second iteration:</li> </ul> \[x^{(2)} = 1.9 - 0.1 \cdot 1 = 1.8\] <ul> <li>Continue iterating until $x$ converges to 0.</li> </ul> <p>However, there might be some convergence problem in the last step. Instead of converging to the actual minimum $x=0$, the iteration might oscillate around it. In this case, we will need to look for the point where the subdifferential includes zero. This is the generalization of the familiar method of finding the minimum by looking for the zero-gradient point, only that the relation gradient=0 is replaced by $0 \in$ subdifferential. To be specific, a point $x^\ast$ is a minimizer of a function $f(x)$ (no necessarily convex) iff $f(x)$ is subdifferentiable at $x^\ast$ and</p> \[0 \in \partial f(x^\ast ),\] <p>i.e. $0$ is a subgradient at $x^\ast$. Using this method it is easy to see that $x=0$ is indeed the minimizer of $\left\lvert x \right\rvert$.</p> <hr> <p><strong>Proximal gradient methods</strong></p> <p>Proximal gradient methods are a generalized form of projection used to solve non-differentiable <a href="https://en.wikipedia.org/wiki/Convex_optimization" title="Convex optimization" rel="external nofollow noopener" target="_blank">convex optimization</a> problems.</p> <p>The function we want to minimize is a composite function</p> \[f(x) = g(x) + h(x),\] <p>where $g(x)$ is supposed to be differentiable while $g(x)$ is not. For example, $h(x)$ could be the LASSO punish term $\left\lVert x \right\rVert_ {2}$. Since $h(x)$ is not differential, we can’t use the gradient descent method directly to $g+h$. However, we can use $g(x)$ to define the gradient method, then somehow include the effect of $h(x)$. The $g$-gradient descent iteration will decrease the value of $g(x)$, then we do something to also decrease the value of $h(x)$, thus the final result will decrease both $g(x)$ and $h(x)$. That’s the general idea of proximal gradient methods, we will explain the word proximal later.</p> <p>Say we start with some intermediate value $x^{(k)}$. First let’s consider $g(x)$ only, and define the quadratic approximation function $\overline{g}^{(l)}(x)$ of $g(x)$ at $x^{(k)}$, that is we use a quadratic function $\overline{g}^{(k)}$ (which is concave) to approximate $g$ around $x^{(k)}$, $\overline{g}$ is constructed such that it is tangent to $g$ at $x^{(k)}$. Specifically,</p> \[\overline{g}^{(k)}(z) = g(x^{(k)}) + (z-x^{(k)}) \nabla g(x^{(k)}) + \frac{1}{2\alpha} (z-x^{(k)})^{2}.\] <p>Gradient descent method using $g(x)$ alone will update it as</p> \[x^{(k+1)}_ {g} := \text{arg min}_ {z}\, \overline{g}^{(k)}(z) = x^{(k)} - \alpha \nabla g(x^{(k)}).\] <p>This is the first step. In the next step, we take into consideration $h(x)$ function and minimize the so-called composite function, which is the sum of the quadratic approximation $\overline{g}$ and the non-differentiable function $h(x)$, the result would be $x^{(k+1)}$, the real $(k+1)$-th iteration:</p> \[x^{(k+1)} := \text{arg min}_ {z}\left\lbrace \overline{g}^{(k)}(z) + h(z) \right\rbrace .\] <p>The logic is</p> \[x^{(k)} \to x^{(k+1)}_ {g} \to x^{(k+1)}.\] <p>I hope it is intuitive. Now let’s try to solve it,</p> \[\begin{align*} x^{(k+1)} &amp;:= \text{arg min}_ {z}\left\lbrace \overline{g}^{(k)}(z) + h(z) \right\rbrace \\ &amp;= \text{arg min}_ {z}\left\lbrace g(x^{(k)}) + (z-x^{(k)}) \nabla g(x^{(k)}) + \frac{1}{2\alpha} (z-x^{(k)})^{2} + h(z) \right\rbrace \\ &amp;= \text{arg min}_ {z}\left\lbrace \frac{1}{2\alpha}[z^{2}-2z(x^{(k)}-\alpha \nabla g)+2 \alpha (g- x^{(k)} \nabla g)] + h(z) \right\rbrace \\ &amp;= \text{arg min}_ {z}\left\lbrace \frac{1}{2\alpha}([z-(x^{(k)}-\alpha\nabla g )]^{2} + C_ {1}) + h(z) \right\rbrace \\ &amp;= \text{arg min}_ {z}\left\lbrace \frac{1}{2\alpha}[z-x^{(k+1)}_ {g}]^{2} + h(z) \right\rbrace, \end{align*}\] <p>where in the fourth line we completed the square and in the last line we got rid of a constant term (independent of $z$) in $\text{arg min}$, since adding to a function a constant term does not change the minimizer of it.</p> <p>Notice that the form of $x^{(k+1)}$ is very similar to the gradient descent method with step size $\alpha$. Regarding $x^{(k+1)}$ we are minimizing some function plus $\frac{1}{2\alpha}(z-x_ {g}^{(k)})^{2}$, while in the gradient descent method where we are minimizing some <strong>linear</strong> function plus $\frac{1}{2\alpha}(z-x^{k})^{2}$. This inspires us to look at $x^{(k+1)}$ with another perspective: we are trying to minimize $h(z)$, in the mean while <strong>trying to stay close to</strong> $x_ {g}^{(k+1)}$. In other words, we are looking for the minimizer of $h(z)$ which is also <strong>proximal</strong> to $x^{(k+1)}_ {g}$. Now it is a good time to introduce <code class="language-plaintext highlighter-rouge">proximal operator</code> $\text{prox}_ {h,\alpha}(x)$, which aims to find the minimizer of function $h$, with step length $\alpha$, proximal to $x$,</p> \[\boxed{ \text{prox}_ {h,\alpha}(x) := \text{arg min}_ {z} \left\lbrace \frac{1}{2\alpha} \left\lVert x-z \right\rVert _ {2}^{2}+h(z) \right\rbrace . }\] <p>The <code class="language-plaintext highlighter-rouge">proximal gradient method</code> works as follows. Given the composite function $f=g+h$ where $g$ is differentiable and $h$ is not. We choose initial value $x^{(0)}$ of $x$, iterate it by repeating</p> \[x^{(k)} := \text{prox}_ {h,\alpha^{(k)}}(x^{(k+1)}_ {g}), \quad x_ {g}^{(k+1)} := x^{(k)} - \alpha^{(k)} \nabla g(x^{(k)}),\] <p>where $\alpha^{(k)}$ is the $k$-th step length.</p> <p>As an example, let’s start with a simple problem that we already know how to solve, apply the proximal gradient method and see how it works. Say we want to minimize a function $f(\beta)$ with only one variable $\beta$,</p> \[f(\beta) = \frac{1}{2} \beta^{2} + \left\lvert \beta-1 \right\rvert .\] <p>The plot is given in the below.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/img/compositeFunction-480.webp 480w,/img/compositeFunction-800.webp 800w,/img/compositeFunction-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/img/compositeFunction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> The test function we want to minimize with proximal gradient method. </div> <p>The minimum is at $\beta=1$, as $0 \in \partial f(\beta){\Large\mid}_ {\beta=1}$. Now let’s try to use the proximal gradient method to solve it. Let us start with</p> \[\beta^{(0)} = 0,\] <p>Use the gradient method with $h(x)=\frac{1}{2} \beta^{2}$ to update the result only, we get</p> \[\beta_ {h}^{(1)} = \beta^{0}-\alpha \nabla h(0) = \beta^{(0)} = 0,\] <p>this is because $h(\beta)$ has zero derivative at $\beta=0$. Next we use proximal operator to update $\beta_ {h}^{(1)}$,</p> \[\begin{align*} \beta^{(1)} &amp;= \text{prox}_ {\left\lvert \bullet-1 \right\rvert,\alpha }(\beta^{(1)}_ {g}) \\ &amp;=\text{arg min}_ {z} \left\lbrace \frac{1}{2\alpha}(z-\beta^{(1)}_ {g})^{2}+\left\lvert z-1 \right\rvert \right\rbrace \\ &amp;= \text{arg min}_ {z} \left\lbrace \frac{1}{2\alpha}z^{2}+\left\lvert z-1 \right\rvert \right\rbrace. \end{align*}\] <p>Now we can use the sub-gradient method to find the minimum. The subgradient reads</p> \[\partial \left( \frac{1}{2\alpha}z^{2}+\left\lvert z-1 \right\rvert \right)= \begin{cases} \frac{z}{\alpha}+1 &amp; z&gt;1 \\ [ \frac{1}{\alpha}-1, \frac{1}{\alpha}+1] &amp; z=1 \\ \frac{z}{\alpha}-1 &amp; z&lt;1 \end{cases}\] <p>it is clear that for any $\alpha$ satisfying $\frac{1}{\alpha}-1&lt;0$ and $\frac{1}{\alpha}+1&gt;0$, zero subgradient is obtained at $z=1$. That is to say, for any $\alpha&gt;0$m we gave</p> \[\beta^{(1)} =1\] <p>which is precisely the result we are looking for. Along the way we have also found a constraint for the value of step size $\alpha$.</p> <hr> <p>Another thing which might be useful is the so-called <code class="language-plaintext highlighter-rouge">soft-thresholding</code> operator, defined as:</p> \[S_ {\lambda}(x) = \text{sign}(x) \cdot \max(\left\lvert x \right\rvert - \lambda, 0)\] <p>where $\lambda$ is a non-negative threshold parameter, $\text{sign}(x)$ returns the sign of $x$, and $\max(\lvert x\rvert - \lambda, 0)$ essentially shrinks $x$ towards zero by $\lambda$, setting it to zero if $x$ is within $\lambda$ of zero.</p> <p>To minimize this function using the soft-thresholding operator, we need to follow these steps:</p> \[S_ {\lambda}(\theta) = \text{sign}(\theta) \cdot \max(\left\lvert \theta \right\rvert - \lambda, 0)\] <hr> <p>For future use, we need to find the Hessian of the loss function $J(\beta)$ from logistic regression, we need to compute the second-order partial derivatives of $J(\beta)$ with respect to the components of the parameter vector $\beta$. Given</p> \[J(\beta) := -\sum_ {i} \left[ y_ i t_ i - \ln(1 + e^{t_ i}) \right], \quad t_ i = \beta_ 0 + \beta \cdot X_ {(i)}.\] <p>where</p> \[t_ i = \beta_ 0 + \sum_ {j=1}^{p} \beta_ j X_ {ij}\] <p>and $\beta = (\beta_ 1, \beta_ 2, \ldots, \beta_ p)$, $X_ {(i)} = (X_ {i1}, X_ {i2}, \ldots, X_ {ip})$.</p> <p>First, we compute the gradient of $J(\beta)$ with respect to $\beta_ 0$ and $\beta_ j$.</p> \[\frac{\partial J(\beta)}{\partial \beta_ 0} = -\sum_ {i} \left[ y_ i - \frac{e^{t_ i}}{1 + e^{t_ i}} \right].\] <p>Let $p_ i = \frac{e^{t_ i}}{1 + e^{t_ i}} = \sigma(t_ i)$, the sigmoid function. Then,</p> \[\frac{\partial J(\beta)}{\partial \beta_ 0} = -\sum_ {i} \left[ y_ i - p_ i \right].\] \[\frac{\partial J(\beta)}{\partial \beta_ j} = -\sum_ {i} \left[ y_ i X_ {ij} - \frac{e^{t_ i}}{1 + e^{t_ i}} X_ {ij} \right].\] <p>Using $p_ i = \sigma(t_ i)$, this becomes:</p> \[\frac{\partial J(\beta)}{\partial \beta_ j} = -\sum_ {i} \left[ y_ i X_ {ij} - p_ i X_ {ij} \right] = -\sum_ {i} X_ {ij} \left[ y_ i - p_ i \right].\] <p>Now we compute the second-order partial derivatives to form the Hessian matrix.</p> <p>Second partial derivative with respect to $\beta_ 0$:</p> \[\frac{\partial^2 J(\beta)}{\partial \beta_ 0^2} = -\sum_ {i} \left[ - \frac{\partial p_ i}{\partial t_ i} \frac{\partial t_ i}{\partial \beta_ 0} \right] = \sum_ {i} p_ i (1 - p_ i).\] <p>Mixed partial derivative with respect to $\beta_ 0$ and $\beta_ j$:</p> \[\frac{\partial^2 J(\beta)}{\partial \beta_ 0 \partial \beta_ j} = -\sum_ {i} \left[ - \frac{\partial p_ i}{\partial t_ i} \frac{\partial t_ i}{\partial \beta_ j} \right] = \sum_ {i} p_ i (1 - p_ i) X_ {ij}.\] <p>Second partial derivative with respect to $\beta_ j$ and $\beta_ k$:</p> \[\begin{align*} \frac{\partial^2 J(\beta)}{\partial \beta_ j \partial \beta_ k} &amp;= -\sum_ {i} \left[ - \frac{\partial p_ i}{\partial t_ i} \frac{\partial t_ i}{\partial \beta_ j} \frac{\partial t_ i}{\partial \beta_ k} \right] = \sum_ {i} p_ i (1 - p_ i) X_ {ij} X_ {ik}\\ &amp;= (X^{T} Q X)_ {jk} \end{align*}\] <p>where $Q_ {mn} = \delta_ {mn}p_ {m}(1-p_ {m})$.</p> <p>The full Hessian matrix $H$ is composed of these second-order partial derivatives. It can be written in block form as follows:</p> \[H = \begin{bmatrix} \frac{\partial^2 J(\beta)}{\partial \beta_ 0^2} &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ 0 \partial \beta_ 1} &amp; \cdots &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ 0 \partial \beta_ p} \\ \frac{\partial^2 J(\beta)}{\partial \beta_ 1 \partial \beta_ 0} &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ 1^2} &amp; \cdots &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ 1 \partial \beta_ p} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial^2 J(\beta)}{\partial \beta_ p \partial \beta_ 0} &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ p \partial \beta_ 1} &amp; \cdots &amp; \frac{\partial^2 J(\beta)}{\partial \beta_ p^2} \end{bmatrix}.\] <p>Using the derived second-order partial derivatives, the Hessian matrix can be written as:</p> \[H = \sum_ {i} p_ i (1 - p_ i) \begin{bmatrix} 1 &amp; X_ {i1} &amp; X_ {i2} &amp; \cdots &amp; X_ {ip} \\ X_ {i1} &amp; X_ {i1}^2 &amp; X_ {i1}X_ {i2} &amp; \cdots &amp; X_ {i1}X_ {ip} \\ X_ {i2} &amp; X_ {i2}X_ {i1} &amp; X_ {i2}^2 &amp; \cdots &amp; X_ {i2}X_ {ip} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ X_ {ip} &amp; X_ {ip}X_ {i1} &amp; X_ {ip}X_ {i2} &amp; \cdots &amp; X_ {ip}^2 \end{bmatrix}.\] <h2 id="42-with-tsallis-statistics">4.2 With Tsallis statistics</h2> <p>There exist tremendous potential in applying Tsallis entropy to biostatistics, mostly for two reasons:</p> <ol> <li>Tsallis statistics modifies logarithmic and exponential functions, and they are ubiquitous in logistic regression methods;</li> <li>Tsallis entropy can seamlessly generalize the familiar Shannon entropy, which is closely connected to the cross entropy loss function, which is exactly the loss functions we used in regression method.</li> </ol> <p>As a starter, in this note we will only focus on the generalization of sigmoid function, keeping other components unchanged. But first, let’s repeat the definition for Tsallis-modified log and exponential functions, so-called $q$-log and $q$-exponentials, for future convenience:</p> \[\begin{align*} \log_ {q} (x) := &amp; \frac{x^{1-q}-1}{1-q}, \\ \exp_ {q}(x) :=&amp; (1+(1-q))^{1/(1-q)}. \end{align*}\] <p>As you can check, at the limit $q\to 1$ they regress to normal log and exp functions.</p> <p><strong>q-sigmoid of the first kind</strong></p> <p>The regular sigmoid function reads</p> \[\sigma(z) = \frac{1}{1+e^{ -z }},\] <p>we generalized it to $q$-sigmoid function:</p> \[\boxed{ \sigma_ {q}(z) := \frac{1}{1+\exp_ {q}(-z)}. }\] <p>To ensure that the range is $[0,1]$ for all $q$, we might need to modified it a little bit, for example multiply by a constant or do some cut-off.</p> <p>The $q$-sigmoid function satisfy the following relation:</p> \[\frac{ \partial \sigma_ {q}(z) }{ \partial z } = \beta(q,z)\sigma_ {q}(z)(1-\sigma_ {q}(z))\] <p>where</p> \[\beta(q,z) = \frac{1}{1-z(1-q)}.\] <p>This should be compared to the case of regular sigmoid function:</p> \[\frac{ \partial \sigma(z) }{ \partial z } = \sigma(z) (1-\sigma(z)).\] <p>The cross entropy loss function now reads</p> \[\boxed{ L= - \sum_ {i=1}^{n}[y_ {i}\log(\sigma _ {q_ {i} }(z_ {i} ))+(1-y_ {i})\log(1-\sigma_ {q_ {i} }(z_ {i} ))]. }\] <p>where $z_ {i}=\theta\cdot X^{(i)}$, $X^{(i)}$ the $i$-th observed data and the q-parameters $q_ {i}$ are different for each sample. Someone write it as $z_ {i}=\theta^{T}X^{(i)}$, but I neglect the transpose symbol since now both $\theta$ and $X$ are understood as vectors. For starters we can set all the $q_ {i}$ as the same constant for all samples, varying about $1$, for example from -0.2 to 1.8 or something. This will greatly reduce the number of free parameters hence prevents over fitting.</p> <p>We will use the gradient method to find the optimal values of parameters that minimized the loss function. Next we work out the derivative of loss function.</p> <p>Some straightforward derivation shows that</p> \[\frac{ \partial L(y,\sigma_ {q}(z)) }{ \partial z } = \beta_ {q}(z)(\sigma_ {q}(z)-y),\] <p>where $\beta_ {q}(z) = \frac{1}{1-z(1-q)}$. The derivative of the loss function with respect to parameters can be readily written as</p> \[\boxed{ \frac{ \partial L(y,\theta) }{ \partial \theta ^{a} } = \sum_ {i} \beta_ {q}(z) (\sigma_ {q}(z_ {i} )-y_ {i})X^{(i)}_ {a}, \quad z_ {i} =\sum_ {a}\theta^{a} \cdot X^{(i)}_ {a} = \theta \cdot X^{(i)}. }\] <p>Note that I have replace $q_ {i}$ with an universal $q$. In contrast to the classical result, there is an extra $\beta$ factor which is nonlinear in both $q$ and $z$.</p> <p>After we plugin this result to gradient method, $\beta(q,z)$ will play a similar rule as $\alpha$, hence in a sense, using $q$-sigmoid naturally introduce the learning rate! We can even set $\alpha=1$ and get</p> \[\hat{\theta}_ {(t)} = \hat{\theta}^{(t-1)} -\beta(q,z)(\sigma_ {q}(z)-y).\] <p>The learning rate $\alpha$ can be chosen according to the Lipschitz constant $L$ as</p> \[\alpha = \frac{1}{L}.\] <hr> <p>Some preliminary results are Obtained and put in the following figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/img/tsallis/Youden1-480.webp 480w,/img/tsallis/Youden1-800.webp 800w,/img/tsallis/Youden1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/img/tsallis/Youden1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Youden index of various regression methods. </div> <hr> <p><strong>q-sigmoid of the second kind</strong></p> <p>Another equivalent expression for the standard sigmoid function reads</p> \[\sigma(z) = \frac{e^{ z }}{e^{ z }+1},\] <p>substitute in the q-exponent function, we have the second kind of q-sigmoid function:</p> \[\overline{\sigma}_ {q}(z) := \frac{\exp_ {q}(z)}{\exp_ {q}+1}.\] <p>This is inequivalent to the q-sigmoid of the first kind since q-exponent satisfy</p> \[\exp_ {q}(z)\exp_ {q}(-z) = \exp_ {q}((1-q)z^{2}) \neq 1.\] <p>The second kind of q-sigmoid can be obtained in another way. The original logistic regression method works like the following: let $p(1\mid z)$ be the measured (real) probability for outcome $1$ and $\hat{p}(1\mid z)$ for the theoretical prediction. The logit function is the bridge between the microscopic information represented by $z$, and the predicted macroscopic measure result $\hat{p}(1\mid z)$, in a linear fashion:</p> \[\text{logit}(\hat{p}) = \log\left( \frac{\hat{p}}{1-\hat{p}} \right)=z.\] <p>We can directly generalize it to $q$-logit function by replacing the log with q-log,</p> \[\text{logit}_ {q}(\hat{p}) := \log_ {q}\left( \frac{\hat{p}}{1-\hat{p}} \right)=z.\] <p>Invert the relation we have</p> \[\hat{p}(1\mid z) := \frac{\exp_ {q}(z)}{\exp_ {q}(z)+1},\] <p>which is the q-sigmoid function of the second kind.</p> <p>We have</p> \[\frac{d}{dz} \overline{\sigma}_ {q}(z) = \overline{\sigma}_ {q} (z)(1-\overline{\sigma}_ {q} (z))\beta _ {q} (-z), \quad \beta _ {q} (-z)=\frac{1}{1+(1-q)z}.\] <p>Note the difference from the q-sigmoid of the first kind, where in the derivative, we have $\beta _ {q}(z)$ instead.</p> <p>The derivative of cross-entropy loss function with respect to the parameters reads</p> \[\boxed{ \frac{ \partial L }{ \partial \theta_ {a} } =\sum_ {i=1}^{n} [\overline{\sigma}_ {q} (z_ {i} )-y_ {i}] \beta _ {q} (-z_ {i} )X^{(i)}_ {a}, \quad z_ {i} =\sum_ {a}\theta_ {a}X^{(i)}_ {a}= \vec{\theta}\cdot \vec{X}^{(i)}. }\] <h1 id="appendix-useful-mathematical-formulae">Appendix. Useful Mathematical Formulae</h1> <p>The definition of $q$-logarithm and $q$-exponential, $x&gt;0, q \in\mathbb{R}$:</p> \[\begin{align*} \ln_ {q}x &amp;:= \frac{x^{1-q}-1}{1-q}, \\ e^{ x }_ {q} &amp;:= (1+(1-q)x)^{1/(1-q)},\quad 0 \text{ if } 1+(1-q)x&lt;0. \end{align*}\] <p>Note that in the definition of the exponential it is required that $1+(1-q)x&gt;0$, otherwise it is defined to be zero. This is to make sure the the value of $e_ {q}$ is positive definite. It is easily checked that $\log <em>q$ and $\exp</em> {q}$ are indeed inverse to each other.</p> <p>many formula for $q$-logarithms reminds us of that for the regular $q$-logarithms.</p> \[\begin{align*} \ln_ {q}(xy) &amp;= \ln_ {q}(x)+ \ln_ {q}(y) + (1-q)\ln_ {q}(x)\ln_ {q}(x) , \\ \ln_ {q}(1+x) &amp;= \sum_ {1}^{\infty} (-1)^{n-1} \frac{(q)_ {n}}{n!} x^{n}, \\ (q)_ {n} &amp;= \frac{\Gamma(q+k)}{\Gamma(q)} = q(q+1)\cdots(q+k-1), \\ \ln_ {q}\prod_ {k=1}^{n}x_ {k} &amp;= \sum_ {k=1}^{n} (1-q)^{k-1}\sum_ {i_ {k} &gt;\cdots&gt;i_ {1}=1}^{n} \ln_ {q}x_ {i_ {1}}\cdots\ln_ {q}x_ {i_ {k}}. \end{align*}\] <p>We also have</p> \[\begin{align*} \ln_ {q} x &amp;= x^{1-q}\ln_ {2-q}x , \\ q \ln_ {1-q}x^{a} &amp;= a \ln_ {1-a} x^{q} . \end{align*}\] <p>Regarding the $q$-exponentials,</p> \[\begin{align*} \left( e_ {q}^{f(x)} \right) ^{a} &amp;= e^{ af(x) }_ {1-(1-q)/a},\\ \frac{d}{dx} e_ {q}^{f(x)} &amp;= (e_ {q}^{f(x)})^{q} \times f'(x) \end{align*}\] <p>For more details, refer to the textbook by Tsallis himself and <a href="https://doi.org/10.1016/S0378-4371(01)00567-2" title="Persistent link using digital object identifier" rel="external nofollow noopener" target="_blank">https://doi.org/10.1016/S0378-4371(01)00567-2</a>.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/displaying-external-posts-on-your-al-folio-blog/">Displaying External Posts on Your al-folio Blog</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Note-on-The-Moral-Foundations-of-Politics/">Note on The Moral Foundations of Politics by Ian Shapiro</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Constructing-a-Finite-Tension-Domain-Wall-in-4D-Part-III/">Constructing a Finite Tension Domain Wall in 4D Part III</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Coleman-Weinberg-Potential/">Note on Coleman-Weinberg Potential</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Thoughts-on-Entropy/">Some Thoughts on Entropy</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Baiyang Zhang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: January 02, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],tags:"all",tagSide:"right",tagIndent:"0.8em",processEscapes:!0},startup:{ready:function(){console.log("MathJax is ready and configured for automatic equation numbering."),MathJax.startup.defaultReady()}}};</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>