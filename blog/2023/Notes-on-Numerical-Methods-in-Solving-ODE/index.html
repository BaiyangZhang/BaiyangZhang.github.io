<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Note on Numerical Methods in Solving ODE | Baiyang Zhang</title> <meta name="author" content="Baiyang Zhang"> <meta name="description" content="A place dedicated to sharing insights and reflections on mathematics, physics, and social sciences. "> <meta name="keywords" content="mathematics, physics, academic-website, portfolio-website"> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],tags:"all",tagSide:"right",tagIndent:"0.8em",processEscapes:!0},startup:{ready:function(){console.log("MathJax is ready and configured for automatic equation numbering."),MathJax.startup.defaultReady()}}};</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/z.png?010ffa0c9cb27051b15dc9ea045f2023"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://baiyangzhang.github.io/blog/2023/Notes-on-Numerical-Methods-in-Solving-ODE/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Baiyang Zhang</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Note on Numerical Methods in Solving ODE</h1> <p class="post-meta">October 31, 2023• Baiyang Zhang</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="introduction">Introduction</h2> <p>In my line of work I sometimes need to solve unsolvable ODEs and PDEs, unsolvable in the sense that it is impossible to get an analytical solution. What we do is to turn to numerical methods for help. For instance, just recently I need to solve a modified version of the Skyrme equation (the equation of motion resulted from the Skyrme model). I thought it would be helpful to summarize what I’ve learnt here.</p> <p>Various numerical methods have been developed to tackle different types of ODEs (initial value problems, boundary value problems, linear, nonlinear, etc.). Here are some of the most popular numerical methods for solving ODEs:</p> <ol> <li> <strong>Euler’s Method</strong>: <ul> <li>This is the simplest one-step method.</li> <li>It’s based on a linear approximation of the solution.</li> <li>While straightforward and instructive for educational purposes, it’s rarely used in practice due to its low accuracy and stability issues.</li> </ul> </li> <li> <strong>Runge-Kutta Methods</strong>: <ul> <li>These are a family of iterative methods.</li> <li>The 4th order Runge-Kutta (often called RK4) is particularly popular due to its balance between accuracy and computational cost.</li> </ul> </li> <li> <strong>Leapfrog (or Midpoint) Method</strong>: <ul> <li>A second-order method that is particularly useful in cases where energy conservation is crucial, such as in molecular dynamics simulations.</li> </ul> </li> <li> <strong>Predictor-Corrector Methods</strong>: <ul> <li>These methods predict a solution using an explicit method and then correct it with an implicit method.</li> <li>Examples include the Adams-Bashforth (predictor) and Adams-Moulton (corrector) methods.</li> </ul> </li> <li> <strong>Backward Differentiation Formulas (BDF)</strong>: <ul> <li>These are implicit multi-step methods.</li> <li>Commonly used for stiff ODEs.</li> </ul> </li> <li> <strong>Multistep Methods</strong>: <ul> <li>These methods use values at multiple previous time steps.</li> <li>Examples include the Adams methods.</li> </ul> </li> <li> <strong>Symplectic Integrators</strong>: <ul> <li>These are used for Hamiltonian systems where preserving the symplectic structure (related to conservation of energy) is essential.</li> </ul> </li> <li> <strong>Implicit Methods</strong>: <ul> <li>Used frequently for stiff equations where explicit methods require prohibitively small time steps.</li> <li>Examples include the backward Euler method and the trapezoidal rule.</li> </ul> </li> <li> <strong>Shooting Method</strong>: <ul> <li>Primarily used for boundary value problems (BVPs).</li> <li>Converts a BVP into an initial value problem (IVP) and then solves the IVP.</li> </ul> </li> <li> <strong>Relaxation Methods</strong>: <ul> <li>Also for boundary value problems.</li> <li>Iteratively refines an initial guess to the solution.</li> </ul> </li> <li> <strong>Finite Difference Method</strong>: <ul> <li>Converts differential equations into <em>difference</em> equations, which can then be solved algebraically.</li> <li>Often used for both ODEs and PDEs.</li> </ul> </li> <li> <strong>Collocation Methods</strong>: <ul> <li>This approach seeks an approximate solution by considering values at specific points (collocation points).</li> </ul> </li> <li> <strong>Continuation method</strong>, which we will go to detail later.</li> </ol> <hr> <p>These methods can be adapted or combined in various ways depending on the specific problem at hand. Moreover, the choice of method often depends on the nature of the ODE (e.g., stiffness), desired accuracy, computational cost considerations, and the specific properties that need to be preserved (e.g., conservation laws).</p> <p>Many modern computational packages and software (like MATLAB, Mathematica, and SciPy in Python) provide built-in functions that implement these methods, which makes it easier for users to solve ODEs without delving deeply into the numerical intricacies of each method.</p> <p><strong>Stiffness.</strong></p> <p>Imagine you’re on a winding road with both smooth curves and sharp turns. If you’re driving a car along this road at a constant speed, the smooth curves can be navigated quite easily, but the sharp turns require more caution and precision.</p> <p>Similarly, in the context of differential equations, there can be parts of the solution that change very slowly (smooth curves) and others that change extremely rapidly (sharp turns). When a differential equation has solutions with widely differing rates of change over its domain, we say that the equation is “stiff.” When you’re solving a stiff differential equation using numerical methods (like the Euler method or the Runge-Kutta method), you’ll notice that the rapid changes require very small step sizes for accurate solutions. However, the slow-changing parts don’t need such small steps. If you choose a step size suitable for the rapidly changing sections (very small), the computation can become inefficient because you’re using more steps than necessary for the slow-changing sections. On the other hand, if you choose a larger step size suitable for the slow-changing sections, the solution can become unstable or highly inaccurate in the rapidly changing sections.</p> <p>To efficiently and accurately solve stiff differential equations, specialized numerical methods have been developed, known as “stiff solvers.” These solvers are designed to adaptively handle the challenges posed by stiffness, allowing for stable and efficient computation.</p> <h2 id="numerical-values-of-parameters">numerical values of parameters</h2> <p>I collected the following values from the Adkins:Nappi:1984 paper<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>,</p> \[m_ {\pi} = 108 \text{ MeV}, \quad e=4.82,\quad F_ {\pi} = \frac{m_ {\pi}}{0.263 e}\] <p>which gives us</p> \[\begin{align} m_ {1} &amp;= 0.526, \\ m_ {2} &amp;= 1.052. \end{align}\] <p>In the chiral case, pion is massless and we have</p> \[\begin{align} m_ {1} &amp;= 0, \\ m_ {2} &amp;= 1.052. \end{align}\] <h2 id="the-shooting-method">The shooting method</h2> <p>The shooting method is a numerical technique used to solve boundary value problems (BVPs) for ordinary differential equations (ODEs). <em>It’s especially useful for second-order ODEs, but can be applied to higher-order equations as well</em>.</p> <p>Here’s a basic overview of the shooting method:</p> <p><strong>The Problem:</strong> Suppose you have a second-order ODE given as:</p> \[y''(x) = f(x, y, y'),\] <p>with boundary conditions:</p> <p>\(y(a) = y_ a\) \(y(b) = y_ b\)</p> <p><strong>The Challenge:</strong> Directly solving the BVP using typical ODE solvers is difficult because standard solvers require initial conditions (values of $y$ and $y’$ at a starting point), rather than boundary conditions at two separate points.</p> <p><strong>The Shooting Method’s Approach:</strong></p> <ol> <li> <p><strong>Guess an Initial Slope</strong>: Choose an initial guess for the derivative $y’(a)$, let’s call it $y’_ a$.</p> </li> <li> <p><strong>Solve as an IVP</strong>: Using the known value $y(a) = y_ a$ and the guessed $y’(a) = y’_ a$ then solve the ODE as an initial value problem (IVP) over the interval $[a, b]$ using standard techniques, like the Runge-Kutta method.</p> </li> <li> <p><strong>Check the Endpoint</strong>: Once you’ve solved the ODE using your initial guess, check the value of $y(b)$ from this solution. Compare it to the desired boundary condition $y_ b$.</p> </li> <li> <p><strong>Adjust the Guess</strong>: If $y(b)$ from your solution is close to $y_ b$, then you’re done. If not, adjust your guess for $y’(a)$ and solve the IVP again. This is typically done using a root-finding algorithm like Newton’s method or the secant method.</p> </li> <li> <p><strong>Iterate</strong>: Repeat steps 2-4 until $y(b)$ from your solution is sufficiently close to $y_ b$, or until a set number of iterations have been reached.</p> </li> </ol> <p>The method’s name comes from the idea that you’re “shooting” from one boundary towards the other. Your first “shot” might miss the target (the second boundary condition). By adjusting your aim (the initial derivative guess) and shoot again, you try to hit the target. The process is repeated until you’re close enough to the target, similar to adjusting one’s aim when firing at a target in marksmanship.</p> <p>While the shooting method can be effective, it’s not guaranteed to work for all BVPs, especially when the underlying ODEs are highly nonlinear or when appropriate initial guesses are hard to ascertain. Unfortunately, the solving of the modified Skyrme equation seems to fall in the category, as I am about to go to details right now.</p> <p>With the parameters listed in the previous chapter, I tried to solve the equation of motion using shooting method with the following codes</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bc1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Pi</span><span class="p">;</span>
<span class="n">bc2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">approximateSolution</span> <span class="o">=</span> <span class="n">Pi</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Tanh</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

<span class="n">initialGuessY</span> <span class="o">=</span> 
  <span class="n">approximateSolution</span> <span class="p">/</span><span class="o">.</span> 
   <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">;</span>  <span class="p">(</span><span class="o">*</span><span class="n">Evaluate</span> <span class="n">approximate</span> <span class="n">solution</span> <span class="n">at</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="p">)</span>
<span class="n">initialGuessYPrime</span> <span class="o">=</span> 
  <span class="n">D</span><span class="p">[</span><span class="n">approximateSolution</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="p">/</span><span class="o">.</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">;</span>  <span class="p">(</span><span class="o">*</span><span class="n">Evaluate</span> <span class="n">derivative</span> <span class="n">at</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="p">)</span>

<span class="n">shootingMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Shooting"</span><span class="p">,</span> 
   <span class="s2">"StartingInitialConditions"</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initialGuessY</span><span class="p">,</span> 
   <span class="n">f</span><span class="o">'</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initialGuessYPrime</span><span class="p">}};</span>

<span class="n">solutionTest1</span> <span class="o">=</span> <span class="n">Module</span><span class="p">[{</span><span class="err">$$</span><span class="n">Eta</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="mf">0.526</span><span class="err">`</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="mf">1.052</span><span class="err">`</span><span class="p">},</span>
	 <span class="n">shootingMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Shooting"</span><span class="p">,</span> 
    <span class="s2">"StartingInitialConditions"</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Pi</span><span class="p">,</span> <span class="n">f</span><span class="o">'</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">}};</span>
  <span class="n">NDSolve</span><span class="p">[{</span><span class="n">eom</span><span class="p">,</span> <span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">},</span> <span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">},</span> <span class="n">PrecisionGoal</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="p">,</span> 
   <span class="n">AccuracyGoal</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="p">]]</span>
</code></pre></div></div> <p>where eom is short for the equation of motion, given by</p> \[\begin{align} \text{eom} =&amp;-2 r^4 f''(r)-4 \eta r^2 f''(r) \sin ^2(f(r))+4 \eta r^3 f'(r)^3-4 r^3 f'(r)^3-4 r^3 f'(r)-2 \eta r^2 f'(r)^2 \sin (2 f(r)) \\ &amp;+6 \eta r^4 f'(r)^2 f''(r)-6 r^4 f'(r)^2 f''(r)+2 \text{m1}^2 r^4 \sin (f(r))+2 \text{m2}^2 r^4 \sin (f(r)) \\ &amp;-\text{m2}^2 r^4 \sin (2 f(r))+2 r^2 \sin (2 f(r))+\sin (2 f(r))-\sin (2 f(r)) \cos (2 f(r)) \\ &amp;==0. \end{align}\] <p>However the computation takes a long time and yields a nonsensical result,</p> <p><img src="/img/eom.png" alt=""></p> <p>which doesn’t make any sense.</p> <hr> <p>For the following discussions, I found paper <a href="https://arxiv.org/abs/1309.1313" rel="external nofollow noopener" target="_blank">arXiv:1309.1313</a> to be most helpful. Below are some approximation we can adopt at $r\to 0$,</p> <p>\(\frac{\sin(f(r))}{r} \to f'(0), \quad \frac{1}{4}-\frac{\sin^2(f(r))}{r^2} -(f'(r))^2 \to \frac{1}{4}\) \(\frac{r^2}{4} + 2\sin^2(f(r)) = \frac{r^2}{4}\left( 1+8\frac{\sin^2(f(r))}{r^2} \right) \to \frac{r^2}{4}(1+8f'(0)).\)</p> <p>Maybe we can make it work by providing a super accurate initial condition? With this hope I try to solve the equation at the origin, close to $r=0$. Expand $f(r)$ about the origin we get</p> \[f(r) = f(0) + r f'(r) = \pi + rg(r),\quad g(r) := f'(r)\] <p>where we have made use of the initial condition that $f(0)=\pi$, and $r$ is supposed to be very small. Take this to the equation of motion, with some manipulation we get</p> \[\left(-4 r^4 g^{2}(r)-2 r^4\right) g'(r)-2 m_ 1^2 r^5 g(r)-4 m_ 2^2 r^5 g(r)-4 r^3 g^{3}(r) =0\] <p>keep the leading order and NLO in $r$ we have</p> \[\left(2 r g^{2}(r)+r\right) g'(r)+2 g^{3}(r)=0\] <p>In paper arXiv:hep-ph/0106150v2, Ponchiano etc. adopted Pade approximation and it seems to be working good. But it’s not directly useful to me.</p> <p>Well let’s move on to the next method.</p> <h2 id="the-continuation-homotopy-embedding-method">The continuation (homotopy, embedding) method</h2> <p>The core idea behind the “continuation method” is that, instead of trying to solve a super-hard problem right away, we start with a simpler version of it that we can solve. Then, we “continue” from that solution, making small changes step by step, until we reach the solution of the original, harder problem.</p> <ol> <li> <strong>Start Simple</strong>: Begin with a version of the problem that’s easy to solve.</li> <li> <strong>Make Small Changes</strong>: Adjust the problem little by little, using the solution from the last step as the starting point for the next.</li> <li> <strong>Reach the Target</strong>: Continue this process until you’ve transformed your simple problem’s solution into a solution for your original, harder problem.</li> </ol> <p>Let us apply the aforementioned philosophical ideas into practice. Suppose we wish to solve a system of $N$ non-linear equations in $N$ variables, say</p> \[F(x) = 0,\quad F: \mathbb{R}^{n} \to \mathbb{R}^{n}.\] <p>We assume $F$ is $C^{\infty}$. Suppose that we don’t know a lot about the initial value of the derivative, then we can’t effectively adopt the shooting method. As a possible remedy, define a homotopy or deformation $H(x,t)$ which deforms from some simpler equations $G(x)$ to $F(x)$ when $t$ smoothly changes, to be specific define</p> \[H(x,0) = G(x),\quad H(x,1) = F(x).\] <p>Everything is required to be smooth here. Typically, one can choose a so-called <code class="language-plaintext highlighter-rouge">convex homotopy</code> such as</p> \[H(x,t) = t\,F(x) + (1-t)\, G(x).\] <p>$H(x,t)$ is the function we are trying to solve. Our job is to find $G(x)$ with known solution, then the PDE that $H(x,t)$ satisfies, offer the initial condition, then try to solve it.</p> <p>Let’s look at an example. Let’s solve the following non-linear partial differential equation, which is a simplified version of the Ginzburg-Landau equation, a fundamental equation in superconductivity theory:</p> \[\frac{\partial u}{\partial t} = \nabla^2 u + \lambda u - u^3\] <p>Here, $u(x, y, t)$ is the field we want to solve for, $\nabla^2 u$ is the Laplacian operator, $\lambda$ is a parameter, and $t$ represents time.</p> <p>Let’s consider a square domain $[0, L] \times [0, L]$ with periodic boundary conditions. We will solve this equation using the continuation method by gradually increasing the parameter $\lambda$ and using the solution from the previous value of $\lambda$ as the initial condition for the next one.</p> <p>This following code defines the PDE and its boundary conditions, then solves it using <code class="language-plaintext highlighter-rouge">NDSolve</code> for a range of values of $\lambda$, starting from $\lambda = 0$ and going up to $\lambda = 1$. The solution for each value of $\lambda$ is used as the initial condition for the next one. Finally, it plots the solution for $\lambda = 1$.</p> <p>Here is the Mathematica code:</p> <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Define the domain size *)</span><span class="w">
</span><span class="nv">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the grid size *)</span><span class="w">
</span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="o">;</span><span class="w">
</span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the time step and final time *)</span><span class="w">
</span><span class="nv">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01</span><span class="o">;</span><span class="w">
</span><span class="nv">tmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the initial condition *)</span><span class="w">
</span><span class="nv">u0</span><span class="p">[</span><span class="nv">x</span><span class="o">_,</span><span class="w"> </span><span class="nv">y</span><span class="o">_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[(</span><span class="nb">Pi</span><span class="o">*</span><span class="nv">x</span><span class="p">)</span><span class="o">/</span><span class="nv">L</span><span class="p">]</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[(</span><span class="nb">Pi</span><span class="o">*</span><span class="nv">y</span><span class="p">)</span><span class="o">/</span><span class="nv">L</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the PDE *)</span><span class="w">
</span><span class="nv">pde</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="p">}]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">D</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="p">}]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">λ</span><span class="o">*</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">^</span><span class="m">3</span><span class="o">;</span><span class="w">

</span><span class="c">(* Solve the PDE using the continuation method *)</span><span class="w">
</span><span class="err">λ</span><span class="nv">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Range</span><span class="p">[</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">0.1</span><span class="p">]</span><span class="o">;</span><span class="w">
</span><span class="nv">usol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="o">;</span><span class="w">
</span><span class="nv">uinit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u0</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span><span class="o">;</span><span class="w">
</span><span class="nb">For</span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nb">Length</span><span class="p">[</span><span class="err">λ</span><span class="nv">values</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="err">λ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">λ</span><span class="nv">values</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">;</span><span class="w">
  </span><span class="nv">sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NDSolve</span><span class="p">[{</span><span class="nv">pde</span><span class="o">,</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">uinit</span><span class="o">,</span><span class="w"> 
    </span><span class="nb">PeriodicBoundaryCondition</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nb">TranslationTransform</span><span class="p">[{</span><span class="nv">L</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="p">}]]</span><span class="o">,</span><span class="w">
    </span><span class="nb">PeriodicBoundaryCondition</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nb">TranslationTransform</span><span class="p">[{</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}]]}</span><span class="o">,</span><span class="w">
   </span><span class="nv">u</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">t</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">}</span><span class="o">,</span><span class="w"> 
   </span><span class="nb">Method</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"MethodOfLines"</span><span class="o">,</span><span class="w"> </span><span class="s">"SpatialDiscretization"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"TensorProductGrid"</span><span class="o">,</span><span class="w"> </span><span class="s">"MaxPoints"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="nv">nx</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="p">}}}]</span><span class="o">;</span><span class="w">
  </span><span class="nb">AppendTo</span><span class="p">[</span><span class="nv">usol</span><span class="o">,</span><span class="w"> </span><span class="nv">sol</span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="nv">uinit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">]</span><span class="w"> </span><span class="o">/.</span><span class="w"> </span><span class="nv">sol</span><span class="o">;</span><span class="w">
</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Plot the solution for λ = 1 *)</span><span class="w">
</span><span class="nv">sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">usol</span><span class="p">[[</span><span class="o">-</span><span class="m">1</span><span class="p">]]</span><span class="o">;</span><span class="w">
</span><span class="nb">Plot3D</span><span class="p">[</span><span class="nb">Evaluate</span><span class="p">[</span><span class="nv">u</span><span class="p">[</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="nv">tmax</span><span class="p">]</span><span class="w"> </span><span class="o">/.</span><span class="w"> </span><span class="nv">sol</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">y</span><span class="o">,</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="nv">L</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nb">AxesLabel</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="o">,</span><span class="w"> </span><span class="s">"y"</span><span class="o">,</span><span class="w"> </span><span class="s">"u"</span><span class="p">}]</span><span class="w">
</span></code></pre></div></div> <p>But before getting our hands dirty let’s consider another similar but different method, for reasons I’ll explain later.</p> <h2 id="the-relaxation-method">The relaxation method</h2> <p>The term “relaxation” refers to the idea that an initial guess at the solution is iteratively refined or “relaxed” until it converges to the true solution.</p> <p><strong>Introduction to the Relaxation Method:</strong></p> <p>The relaxation method is often used for solving elliptic PDEs, such as Laplace’s equation and Poisson’s equation. The general approach of the relaxation method is as follows:</p> <ol> <li>Discretize the domain of the PDE into a grid or mesh.</li> <li>Make an initial guess for the solution at each grid point.</li> <li>Iteratively update the solution at each grid point using a numerical approximation of the PDE.</li> <li>Repeat step 3 until the solution converges to within a specified tolerance.</li> </ol> <p>Let’s consider an example of solving Laplace’s equation on a rectangular domain $[0, a] \times [0, b]$ with Dirichlet boundary conditions.</p> <p>Laplace’s equation is given by:</p> \[\nabla^2 u(x, y) = 0\] <p>Where $u(x, y)$ is the function we are trying to solve for, and $\nabla^2$ is the Laplacian operator.</p> <p>For simplicity, let’s consider the case where $a = b = 1$, and the boundary conditions are:</p> \[u(0, y) = 0, \quad u(1, y) = 0, \quad u(x, 0) = 0, \quad u(x, 1) = \sin(\pi x)\] <p>Here are the steps to solve this problem using the relaxation method in Mathematica:</p> <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Define the domain size *)</span><span class="w">
</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">
</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the grid size *)</span><span class="w">
</span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">
</span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the boundary conditions *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Table</span><span class="p">[</span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">j</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">j</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nb">Do</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[</span><span class="nb">Pi</span><span class="o">*</span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="o">/</span><span class="nv">nx</span><span class="p">]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the relaxation parameter *)</span><span class="w">
</span><span class="nv">omega</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.5</span><span class="o">;</span><span class="w">

</span><span class="c">(* Define the tolerance for convergence *)</span><span class="w">
</span><span class="nv">tol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="m">6</span><span class="p">)</span><span class="o">;</span><span class="w">

</span><span class="c">(* Perform the relaxation iteration *)</span><span class="w">
</span><span class="nv">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">;</span><span class="w">
</span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">;</span><span class="w">
</span><span class="nb">While</span><span class="p">[</span><span class="nv">error</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">tol</span><span class="o">,</span><span class="w">
  </span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="o">;</span><span class="w">
  </span><span class="nb">For</span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">nx</span><span class="o">,</span><span class="w"> </span><span class="nv">i</span><span class="o">++,</span><span class="w">
    </span><span class="nb">For</span><span class="p">[</span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">ny</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="o">++,</span><span class="w">
      </span><span class="nv">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="o">;</span><span class="w">
      </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">omega</span><span class="p">)</span><span class="o">*</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">omega</span><span class="o">*</span><span class="m">0.25</span><span class="o">*</span><span class="p">(</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">]])</span><span class="o">;</span><span class="w">
      </span><span class="nv">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Max</span><span class="p">[</span><span class="nv">error</span><span class="o">,</span><span class="w"> </span><span class="nb">Abs</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="nv">j</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">old</span><span class="p">]]</span><span class="o">;</span><span class="w">
    </span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="p">]</span><span class="o">;</span><span class="w">
  </span><span class="nv">iteration</span><span class="o">++;</span><span class="w">
</span><span class="p">]</span><span class="o">;</span><span class="w">

</span><span class="c">(* Display the result *)</span><span class="w">
</span><span class="nv">u</span><span class="w">
</span></code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">u</code> matrix contains the approximate solution to the PDE at each grid point. The <code class="language-plaintext highlighter-rouge">While</code> loop continues iterating until the maximum change in the solution at any grid point is less than the specified tolerance <code class="language-plaintext highlighter-rouge">tol</code>.</p> <p>The relaxation method is a powerful and widely used numerical technique for solving PDEs. It is particularly well-suited for solving elliptic PDEs, such as Laplace’s equation and Poisson’s equation, which arise in various physical applications. The method is relatively simple to implement and can be easily adapted to different types of PDEs and boundary conditions.</p> <p>However, it’s important to note that the convergence of the relaxation method can be sensitive to the choice of the relaxation parameter <code class="language-plaintext highlighter-rouge">omega</code> and the grid size. In some cases, it may be necessary to experiment with different values of these parameters to achieve a satisfactory solution.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Nuclear Physics B233 (1984) 109-115, doi: 10.1016/0550-3213(84)90172-x <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/displaying-external-posts-on-your-al-folio-blog/">Displaying External Posts on Your al-folio Blog</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Tsallis-Statistics-in-Logistic-Regression/">Tsallis Statistics in Logistic Regression</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Calculating-States-Using-Diagrams/">Calculating States Using Diagrams</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Asymptotic-Methods-Applied-on-Anharmonic-Oscillator/">Asymptotic Methods Applied on Anharmonic Oscillator</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Rules-for-Jarah-Diagrams/">Diagrammatic Rules for Jarah Diagrams</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Baiyang Zhang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: October 30, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],tags:"all",tagSide:"right",tagIndent:"0.8em",processEscapes:!0},startup:{ready:function(){console.log("MathJax is ready and configured for automatic equation numbering."),MathJax.startup.defaultReady()}}};</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>